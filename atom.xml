<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>御风而行</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://donald-zhuang.github.io/"/>
  <updated>2018-12-15T16:44:14.742Z</updated>
  <id>https://donald-zhuang.github.io/</id>
  
  <author>
    <name>Donald.Zhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内核线程卡死两例——sysrq运用简例</title>
    <link href="https://donald-zhuang.github.io/2018/12/15/SysrqInDebug/"/>
    <id>https://donald-zhuang.github.io/2018/12/15/SysrqInDebug/</id>
    <published>2018-12-15T09:32:04.000Z</published>
    <updated>2018-12-15T16:44:14.742Z</updated>
    
    <content type="html"><![CDATA[<p>　　这阵子一直在处理各种死机和STR开关机问题，虽说稍微有点虐，不过技术面的扩展和更多新技巧的学习了解，也让我挺enjoy的。kernel世界对我来说，一直是一个black box，很迷。随着上阵子切bionic、看完程序员的自我修养以及这阵子为处理一个语音唤醒问题学习AN8.0的DC待机流程，发现这个是通过reboot函数做syscall进kernel待机，感觉打开一个新世界。虽然之前也是知道这条通路，但当问题和整个代码流程浮现在你面前时，一切依旧像盒子中的巧克力让你兴奋不已。<br><a id="more"></a></p><hr><p>　　这篇文章首先通过一个实例介绍sysrq debug定位进程卡死问题，之前我没接触过sysrq，因此这次是由alix分析完之后，请他指导我怎么分析流程，而我还没去看sysrq部分的代码和实现机理。随后，介绍另一个通过修改线程在内核中的调度策略和优先级导致异常CPU占用的问题，我这边是先怀疑，然后请客户review code确认，后续有现场由Futang通过ICE分析线程参数确认问题。这次都是不太熟悉的东西，因为有bug请评论指出。</p><h3 id="1-Driver异常问题"><a href="#1-Driver异常问题" class="headerlink" title="1. Driver异常问题"></a>1. Driver异常问题</h3><p>　　问题系统为AN8.0，运行在4核系统上，接USB CAM卡做切台压测，异常时UI操作能够响应，有一个进程卡死，导致TV应用卡在某一帧画面上，不运行。通过复现抓取log，分析到卡在某个接口的CMA申请上，具体如下：<br><img src="/2018/12/15/SysrqInDebug/AllocCMA.png" title="where the process hang"><br>　　一般申请不到CMA就是内存不足，不过我司的平台比较特殊，一些关键IP是有专用的memory，因此一般不会出现这种问题。在异常发生时，我这边分析了整体系统的内存情况正常，对应申请的memory部分也很充足，照理不应该卡住的。又因无下手点，所以请kernel team的alix指导处理，如下也就是他的分析了。<br>　　1. 透過sysrq check blocked state,可以知道Binder:2058_7 3(PID 3224) 目前為 block 的狀態，卡在CMA申请上面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">735.108723</span>] sysrq: SysRq : HELP : loglevel(<span class="number">0</span><span class="number">-9</span>) reboot(b) crash(c) terminate-all-tasks(e) memory-full-oom-kill(f) kill-all-tasks(i) thaw-filesystems(j) sak(k) show-backtrace-all-active-cpus(l) show-memory-usage(m) nice-all-RT-tasks(n) poweroff(o) show-registers(p) show-all-timers(q) unraw(r) sync(s) show-task-states(t) unmount(u) show-blocked-tasks(w) dump-ftrace-buffer(z)</span><br><span class="line">[  <span class="number">738.933149</span>] sysrq: SysRq : Show Blocked State</span><br><span class="line">[  <span class="number">738.937536</span>]task                        PC <span class="built_in">stack</span>   pid father</span><br><span class="line">[  <span class="number">739.091866</span>] Binder:<span class="number">2058</span>_7   D0  <span class="number">3224</span>   <span class="number">2012</span> <span class="number">0x00400008</span></span><br><span class="line">[  <span class="number">739.097368</span>] Call trace:</span><br><span class="line">[  <span class="number">739.099820</span>] [&lt;ffffff800808bf8c&gt;] __switch_to+<span class="number">0x8c</span>/<span class="number">0xac</span></span><br><span class="line">[  <span class="number">739.104966</span>] [&lt;ffffff8008a3bec4&gt;] __schedule+<span class="number">0x1b0</span>/<span class="number">0xdac</span></span><br><span class="line">[  <span class="number">739.110196</span>] [&lt;ffffff8008a3caf8&gt;] schedule+<span class="number">0x38</span>/<span class="number">0x98</span></span><br><span class="line">[  <span class="number">739.115078</span>] [&lt;ffffff8008a3fab0&gt;] schedule_timeout+<span class="number">0x1cc</span>/<span class="number">0x374</span></span><br><span class="line">[  <span class="number">739.120829</span>] [&lt;ffffff8008a3d704&gt;] wait_for_common+<span class="number">0xb4</span>/<span class="number">0x158</span></span><br><span class="line">[  <span class="number">739.126406</span>] [&lt;ffffff8008a3d7bc&gt;] wait_for_completion+<span class="number">0x14</span>/<span class="number">0x1c</span></span><br><span class="line">[  <span class="number">739.132243</span>] [&lt;ffffff80080da87c&gt;] flush_work+<span class="number">0xcc</span>/<span class="number">0x140</span></span><br><span class="line">[  <span class="number">739.137389</span>] [&lt;ffffff80081e3a94&gt;] lru_add_drain_all+<span class="number">0x13c</span>/<span class="number">0x188</span></span><br><span class="line">[  <span class="number">739.143228</span>] [&lt;ffffff8008256e2c&gt;] migrate_prep+<span class="number">0xc</span>/<span class="number">0x18</span></span><br><span class="line">[  <span class="number">739.148373</span>] [&lt;ffffff80081dcc78&gt;] alloc_contig_range+<span class="number">0xec</span>/<span class="number">0x3f8</span></span><br><span class="line">[  <span class="number">739.154213</span>] [&lt;ffffff800826293c&gt;] dma_alloc_at_from_contiguous+<span class="number">0x160</span>/<span class="number">0x474</span></span><br><span class="line">[  <span class="number">739.161010</span>] [&lt;ffffff80087b9b94&gt;] CMA_Pool_ioctl+<span class="number">0x5fc</span>/<span class="number">0x2364</span></span><br><span class="line">[  <span class="number">739.166674</span>] [&lt;ffffff80087b6278&gt;] Compat_CMA_Pool_ioctl+<span class="number">0xd10</span>/<span class="number">0x1318</span></span><br><span class="line">[  <span class="number">739.172950</span>] [&lt;ffffff80082cc740&gt;] compat_SyS_ioctl+<span class="number">0xbc</span>/<span class="number">0x294</span></span><br><span class="line">[  <span class="number">739.178614</span>] [&lt;ffffff8008082e70&gt;] el0_svc_naked+<span class="number">0x24</span>/<span class="number">0x28</span></span><br></pre></td></tr></table></figure></p><p>　　2. Blocked task Backtrace 中 lru_add_drain_all 中的 flush_work 會讓其他所有 cpu 強迫將 workqueue 的事情做完才離開，因此懷疑的方向改為分析 workqueue 卡住。注：这部分深入可以参考<a href="http://oenhan.com/rwsem-realtime-task-hung" title="读写信号量与实时进程阻塞挂死问题" target="_blank" rel="noopener">读写信号量与实时进程阻塞挂死问题</a><br>　　3. 透過 sysrq dump workqueue status 可以看CPU2 的 workqueue 卡住了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">922.802525</span>] workqueue lru-add-drain: flags=<span class="number">0x8</span></span><br><span class="line">[  <span class="number">922.806970</span>]pwq <span class="number">4</span>: cpus=<span class="number">2</span> node=<span class="number">0</span> flags=<span class="number">0x0</span> nice=<span class="number">0</span> active=<span class="number">1</span>/<span class="number">256</span></span><br><span class="line">[  <span class="number">922.813027</span>]     pending: lru_add_drain_per_cpu BAR(<span class="number">3224</span>)</span><br></pre></td></tr></table></figure></p><p>　　4. 透過 sysrq dump all cpu (特別是cpu2), 得知CPU2 目前的 PC 值為 el0_irq_naked+48/0x50<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">2167.926823</span>] sysrq: CPU2:</span><br><span class="line">[ <span class="number">2167.929358</span>] Call trace:</span><br><span class="line">[ <span class="number">2167.931810</span>] [&lt;ffffff800808f4fc&gt;] dump_backtrace+<span class="number">0x0</span>/<span class="number">0x1a4</span></span><br><span class="line">[ <span class="number">2167.937210</span>] [&lt;ffffff800808f6b4&gt;] show_stack+<span class="number">0x14</span>/<span class="number">0x1c</span></span><br><span class="line">[ <span class="number">2167.942263</span>] [&lt;ffffff800852f4a8&gt;] showacpu+<span class="number">0x5c</span>/<span class="number">0x6c</span></span><br><span class="line">[ <span class="number">2167.947145</span>] [&lt;ffffff8008147e4c&gt;] flush_smp_call_function_queue+<span class="number">0x94</span>/<span class="number">0x16c</span></span><br><span class="line">[ <span class="number">2167.953934</span>] [&lt;ffffff8008148c5c&gt;] generic_smp_call_function_single_interrupt+<span class="number">0x10</span>/<span class="number">0x18</span></span><br><span class="line">[ <span class="number">2167.961767</span>] [&lt;ffffff8008098f40&gt;] handle_IPI+<span class="number">0x180</span>/<span class="number">0x298</span></span><br><span class="line">[ <span class="number">2167.966992</span>] [&lt;ffffff8008081514&gt;] gic_handle_irq+<span class="number">0xa4</span>/<span class="number">0xbc</span></span><br><span class="line">[ <span class="number">2167.972389</span>] <span class="function">Exception <span class="title">stack</span><span class="params">(<span class="number">0xffffffc06cf3bec0</span> to <span class="number">0xffffffc06cf3bff0</span>)</span></span></span><br><span class="line">[ 2167.978830] bec0: 00000000e7d00000 0000000000017800 00000000e7c02928 00000000eb76fb5c</span><br><span class="line">[ <span class="number">2167.986660</span>] bee0: <span class="number">00000000e7</span>d00000 <span class="number">00000000e7</span>c02928 <span class="number">00000000</span>eb79ef60 <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2167.994489</span>] bf00: <span class="number">0000000000000000</span> <span class="number">00000000</span>eb79ef58 <span class="number">00000000e7</span>c02928 <span class="number">00000000</span>eb79ef44</span><br><span class="line">[ <span class="number">2168.002319</span>] bf20: <span class="number">0000000000017800</span> <span class="number">00000000e7</span>c02898 <span class="number">00000000</span>eb5d5400 <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.010149</span>] bf40: <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.017979</span>] bf60: <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.025808</span>] bf80: <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.033637</span>] bfa0: <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span> <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.041468</span>] bfc0: <span class="number">00000000</span>eb5d2b3c <span class="number">00000000</span>a00f0010 <span class="number">0000000000000024</span> ffffffffffffffff</span><br><span class="line">[ <span class="number">2168.049297</span>] bfe0: <span class="number">0000000000000000</span> <span class="number">0000000000000000</span></span><br><span class="line">[ <span class="number">2168.054174</span>] [&lt;ffffff8008082c88&gt;] el0_irq_naked+<span class="number">0x48</span>/<span class="number">0x50</span></span><br></pre></td></tr></table></figure></p><p>　　5. 通过重复sysrq dump all CPU status，我们可以看到Exception Stack一直不变,因此查看CPU2上处于running的task确认为PID 2548占着没退出。而这个task的调用栈如下，我们可以看到异常时卡在media_intf_read这只函数上，该函数采用自旋锁，不能进行处理器抢占，其他进程无法获取CPU，因此需要请对应的kernel driver owner定位下media_intf_read卡住的原因。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">2167.972389</span>] <span class="function">Exception <span class="title">stack</span><span class="params">(<span class="number">0xffffffc06cf3bec0</span> to <span class="number">0xffffffc06cf3bff0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[10148.240821] hstvos R running task 0 2548 2122 0x00400000</span><br><span class="line">[<span class="number">10148.247899</span>] Call trace:</span><br><span class="line">[<span class="number">10148.250353</span>] [&lt;ffffff800808bf8c&gt;] __switch_to+<span class="number">0x8c</span>/<span class="number">0xac</span></span><br><span class="line">[<span class="number">10148.255497</span>] [&lt;ffffff80080eae84&gt;] preempt_count_add+<span class="number">0x100</span>/<span class="number">0x11c</span></span><br><span class="line">[<span class="number">10148.261337</span>] [&lt;ffffff8008a406fc&gt;] _raw_spin_lock_irqsave+<span class="number">0x20</span>/<span class="number">0x60</span></span><br><span class="line">[<span class="number">10148.267435</span>] [&lt;ffffff8008a409ac&gt;] _raw_spin_unlock_irqrestore+<span class="number">0x20</span>/<span class="number">0x44</span></span><br><span class="line">[<span class="number">10148.273968</span>] [&lt;ffffff800810cc78&gt;] finish_wait+<span class="number">0x5c</span>/<span class="number">0x7c</span></span><br><span class="line">[<span class="number">10148.279112</span>] [&lt;ffffff80086683c0&gt;] media_intf_read+<span class="number">0x154</span>/<span class="number">0x374</span></span><br><span class="line">[<span class="number">10148.284775</span>] [&lt;ffffff8008266ea8&gt;] __vfs_read+<span class="number">0x28</span>/<span class="number">0x108</span></span><br><span class="line">[<span class="number">10148.289917</span>] [&lt;<span class="number">0000000000000001</span>&gt;] <span class="number">0x1</span></span><br></pre></td></tr></table></figure></p><p>　　在达成如上分析后，请客户找USB CAM卡驱动的设计者，回复信息如下，这个反馈也符合了问题现象，异常时拔卡、发signal都能恢复正常。问题也就会回归为media_intf_write为何没有执行了，客户反馈如果hs_UsbCam_Create没有执行完就会出现media_intf_write不执行。</p><blockquote><p>usbcam读写设计是阻塞的，如果没有media write的话，那media read接口会一直阻塞(除非拔出usbcam、close fd或者被信号杀死等特殊情况)。</p></blockquote><p>　　通过生成coredump确认异常时这个函数卡住的位置，再与客户沟通上层实现逻辑（看不到code…），我梳理出如下一个死锁通路。因为两个流程是在不同线程上跑的，且未加同步机制保证时序，故而有机会出现deadlock。分析完，这个问题的修正方式也就浮出水面：只要保证media_intf_read在media_intf_write之后执行，保证hs_usbcam_create执行完之后才能执行vhal_start，就能避免死锁条件的形成，问题也就解决。<br><img src="/2018/12/15/SysrqInDebug/Deadlock.png" title="the figure of deadlock"></p><h3 id="2-CPU占用100-问题"><a href="#2-CPU占用100-问题" class="headerlink" title="2. CPU占用100%问题"></a>2. CPU占用100%问题</h3><p>　　修正如上问题后，出现小概率客户中间件进程100%占用某颗CPU的情况出现。采用同样的方式分析，可以看到一个未知线程一直占住CPU没有放。直觉怀疑是客户对线程调度策略进行修改，后请客户review code，确认了假想。其实现类似如下，也就是将进程设定为FIFO且优先级为最高。我们后面通过ICE也可以看到异常线程的这个参数设定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"><span class="keyword">int</span> rs;</span><br><span class="line"><span class="keyword">int</span> policy;</span><br><span class="line"></span><br><span class="line">rs=pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);</span><br><span class="line">param.sched_priority = <span class="number">99</span>;</span><br><span class="line">pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">pthread_create(&amp;threadId, attr, (<span class="keyword">void</span>*)thread_start_task, <span class="literal">NULL</span>);</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure></p><p>　　从Linux Programmer’s Manual的<a href="http://man7.org/linux/man-pages/man7/sched.7.html" title="sched" target="_blank" rel="noopener">SCHED</a>一节可以看到如下说明，SCHED_FIFO一旦占用cpu便会一直运行(CHED_FIFO is a simple scheduling algorithm without time slicing.)，直到有IO请求、更高优先级任务到达或主动退出(sched_yield)才释放CPU，他和RR都是有很高的调度优先级的。因此代码上对线程调度控制的修改也要十分谨慎，不然很容易出现问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">SCHED_FIFO: First in-first out scheduling</span><br><span class="line">    SCHED_FIFO can be used only with <span class="keyword">static</span> priorities higher than <span class="number">0</span>,</span><br><span class="line">    which means that when a SCHED_FIFO threads becomes runnable, it will</span><br><span class="line">    always immediately preempt any currently running SCHED_OTHER,</span><br><span class="line">    SCHED_BATCH, <span class="keyword">or</span> SCHED_IDLE thread.  SCHED_FIFO is a simple scheduling</span><br><span class="line">    algorithm without time slicing.  For threads scheduled under the</span><br><span class="line">    SCHED_FIFO policy, the following rules apply:</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>) A running SCHED_FIFO thread that has been preempted by another</span><br><span class="line">       thread of higher priority will stay at the head of the <span class="built_in">list</span> <span class="keyword">for</span></span><br><span class="line">       its priority <span class="keyword">and</span> will resume execution as soon as all threads of</span><br><span class="line">       higher priority are blocked again.</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>) When a blocked SCHED_FIFO thread becomes runnable, it will be</span><br><span class="line">       inserted at the end of the <span class="built_in">list</span> <span class="keyword">for</span> its priority.</span><br><span class="line"></span><br><span class="line">    3) If a call to sched_setscheduler(2), sched_setparam(2),</span><br><span class="line">       sched_setattr(<span class="number">2</span>), pthread_setschedparam(<span class="number">3</span>), <span class="keyword">or</span></span><br><span class="line">       pthread_setschedprio(<span class="number">3</span>) changes the priority of the running <span class="keyword">or</span></span><br><span class="line">       runnable SCHED_FIFO thread identified by pid the effect on the</span><br><span class="line">       thread's position in the <span class="built_in">list</span> depends on the direction of the</span><br><span class="line">       change to threads priority:</span><br><span class="line"></span><br><span class="line">       ·  If the thread's priority is raised, it is placed at the end of</span><br><span class="line">          the <span class="built_in">list</span> <span class="keyword">for</span> its <span class="keyword">new</span> priority.  As a consequence, it may</span><br><span class="line">          preempt a currently running thread with the same priority.</span><br><span class="line"></span><br><span class="line">       ·  If the thread's priority is unchanged, its position in the run</span><br><span class="line">          <span class="built_in">list</span> is unchanged.</span><br><span class="line"></span><br><span class="line">       ·  If the thread's priority is lowered, it is placed at the front</span><br><span class="line">          of the <span class="built_in">list</span> <span class="keyword">for</span> its <span class="keyword">new</span> priority.</span><br><span class="line"></span><br><span class="line">       According to POSIX<span class="number">.1</span><span class="number">-2008</span>, changes to a thread's priority (<span class="keyword">or</span></span><br><span class="line">       policy) <span class="keyword">using</span> any mechanism other than pthread_setschedprio(<span class="number">3</span>)</span><br><span class="line">       should result in the thread being placed at the end of the <span class="built_in">list</span></span><br><span class="line">       <span class="keyword">for</span> its priority.</span><br><span class="line"></span><br><span class="line">    <span class="number">4</span>) A thread calling sched_yield(<span class="number">2</span>) will be put at the end of the</span><br><span class="line">       <span class="built_in">list</span>.</span><br><span class="line"></span><br><span class="line">    No other events will move a thread scheduled under the SCHED_FIFO</span><br><span class="line">    policy in the wait <span class="built_in">list</span> of runnable threads with equal <span class="keyword">static</span></span><br><span class="line">    priority.</span><br><span class="line"></span><br><span class="line">    A SCHED_FIFO thread runs until either it is blocked by an I/O</span><br><span class="line">    request, it is preempted by a higher priority thread, <span class="keyword">or</span> it calls</span><br><span class="line">    sched_yield(<span class="number">2</span>).</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这阵子一直在处理各种死机和STR开关机问题，虽说稍微有点虐，不过技术面的扩展和更多新技巧的学习了解，也让我挺enjoy的。kernel世界对我来说，一直是一个black box，很迷。随着上阵子切bionic、看完程序员的自我修养以及这阵子为处理一个语音唤醒问题学习AN8.0的DC待机流程，发现这个是通过reboot函数做syscall进kernel待机，感觉打开一个新世界。虽然之前也是知道这条通路，但当问题和整个代码流程浮现在你面前时，一切依旧像盒子中的巧克力让你兴奋不已。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="sysrq" scheme="https://donald-zhuang.github.io/tags/sysrq/"/>
    
      <category term="sched" scheme="https://donald-zhuang.github.io/tags/sched/"/>
    
  </entry>
  
  <entry>
    <title>记一次DFB异常问题处理和思考</title>
    <link href="https://donald-zhuang.github.io/2018/11/30/BugFromDFB/"/>
    <id>https://donald-zhuang.github.io/2018/11/30/BugFromDFB/</id>
    <published>2018-11-30T14:10:04.000Z</published>
    <updated>2018-12-01T14:40:40.076Z</updated>
    
    <content type="html"><![CDATA[<p>　　本周处理的诸多问题中有两个是串联起来的，都是DFB相关的问题，一个是FD Leak，一个是创建线程没退出，这两个问题的处理过程本不是很复杂，常规手段即可处理，但这次debug过程中，暴露出一些coding上的问题，也是一个提醒。<br><a id="more"></a></p><hr><p>　　这次问题我也初步总结FD leak的常规处理手段，可直接查看<a href="#fd-leak-debug-method">FD leak debug流程</a></p><h3 id="问题处理过程"><a href="#问题处理过程" class="headerlink" title="问题处理过程"></a>问题处理过程</h3><p>　　此次问题环境是HDMI信源下做timming切换压测，每14s一次，timming切换之间会断掉信号然后重送信号，后台有进程在信号变化时截图，压测约5到6小时出现一次异常，产生coredump trace类似如下，当然这个是构造的，避免资安问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#0 0xf0402d5c in raise () from /lib/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0 0xf0402d5c in raise () from /lib/libc.so.6</span><br><span class="line">#1 0xf0406838 in abort () from /lib/libc.so.6</span><br><span class="line">#<span class="number">2</span> <span class="number">0xf0d60c04</span> in __android_log_assert () from /mslib/libXXXXX.so</span><br><span class="line">#<span class="number">3</span> <span class="number">0xf0d58310</span> in android::RefBase::decStrong(<span class="keyword">void</span> <span class="keyword">const</span>*) <span class="keyword">const</span> ()from /mslib/libXXXXX.so</span><br><span class="line">#<span class="number">4</span> <span class="number">0x0b10ec78</span> in XxXXXService::connect(android::sp&lt;IXxXXXClient&gt; <span class="keyword">const</span>&amp;) ()</span><br><span class="line">.......</span><br><span class="line">#<span class="number">10</span> <span class="number">0x0afd8114</span> in XxResourceHandle::~XxResourceHandle() ()</span><br><span class="line">#<span class="number">11</span> <span class="number">0x0afd8f88</span> in object_buffer&lt;XxResourceHandle, <span class="number">256</span>&gt;::~object_buffer() ()</span><br><span class="line">#<span class="number">12</span> <span class="number">0x0afd8fd8</span> in object_count_manager&lt;xx_atomic, object_buffer&lt;XxResourceHandle, <span class="number">256</span>&gt; &gt;::~object_count_manager() ()</span><br><span class="line">#<span class="number">13</span> <span class="number">0xe939b0c0</span> in __run_exit_handlers ()</span><br><span class="line">#14 0xf040815c in exit () from /lib/libc.so.6</span><br><span class="line">#15 0xf07bdf4c in dfb_core_destroy_handler () from /mslib/libdirectfb-1.4.so.0</span><br><span class="line">#<span class="number">16</span> <span class="number">0xf0ef3184</span> in ?? () from /lib/libpthread.so<span class="number">.0</span></span><br><span class="line">Cannot access memory at address <span class="number">0x0</span></span><br><span class="line">#<span class="number">17</span> <span class="number">0xf04a3028</span> in ?? () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">Cannot access memory at address <span class="number">0x0</span></span><br><span class="line">Backtrace stopped: <span class="function">previous frame identical to <span class="keyword">this</span> <span class="title">frame</span> <span class="params">(corrupt <span class="built_in">stack</span>?)</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> q</span></span><br></pre></td></tr></table></figure></p><p>　　按照大部分新手的习惯，解coredump出来，看到abort首先会去看那个位置的code，查引发abort的原因（以前的我也会）。但这一例中，如果按照这样的思路去查，就会陷入无底洞，查不到原因。后面你也会发现每次压测出来的trace的位置不断变化，由此可能会以为是踩内存、并发之类的问题，绕了弯路。若仔细一看，你会发现异常点是dfb_core_destroy_handler中调用了exit。<br>　　在这一例中看到exit基本也就定位到问题点了，异常的原因是dfb_core_destroy_handler中调用了exit，exit退出时会去析构全局和静态对象，带出了其他问题。根据<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4727.pdf" title="ISO 2003 C++ Standard" target="_blank" rel="noopener">ISO 2003 C++ standard</a>的要求，exit函数在退出时会调用相关的对象的析构函数来释放资源，具体定义如下。<br><img src="/2018/11/30/BugFromDFB/exit.png" title="definition of exit"><br>　　我们可以通过下面的demo程序体验标准中的规定，特别指出，例子中a2对象满足“Automatic objects are not destroyed as a result of calling exit()”，因为它是栈上分配的。由此可见，这问题的本质也就是查exit被call的原因。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> x): num(x)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo(<span class="keyword">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"exit in destrution"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Num[%d] exit in destrution\r\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> demo <span class="title">a3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"exit in main\r\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　通过开log压测一晚复现问题，我们看到DFB在初始化阶段，调用dlopen时failed，提示log为“Too many open files”。这个log就是典型的FD leak问题，这部分可以参考<a href="https://www.jianshu.com/p/befd4b86cc42" title="Android-Stability【Fdleak】: Android Fd泄漏问题分析" target="_blank" rel="noopener">Android-Stability【Fdleak】: Android Fd泄漏问题分析</a>的说明。这个问题也就是当前进程中open了过多的fd导致dlopen时failed了。</p><blockquote><p>01-01 09:58:51.724 2045 2045 I XXXXX: –&gt; /mslib/directfb-1.4-0/wm/libdirectfbwm_default.so: cannot open shared object file: Too many open files</p></blockquote><p>　　请DFB owner review相关code，确认dlopen、dlclose调用成对，不会出现leak的问题，也就需要从对应进程的角度上分析。当进程异常退出时，所有资源被释放掉，也就没法看到什么内容leak了。这也就要求我们每压测一段时间，抓取/proc/$PID/fd下的信息，然后对比初始的，看增长的文件是哪些。<br>　　手动压测几次后，“ls -l /proc/$PID/fd | grep . -c”统计fd数量变化，发现每次切换timming后都会增长4个fd。通过比对timming切换前后/proc/$PID/fd下内容的变化，我们发现是pipe leak。由此我们可以通过lsof来确认是哪些进程线程在用这个pipe，用法类似如下，”lsof | grep $pipp_id”定位。Unfortunately，异常时发现只有当前进程用着这个pipe，这也就说明，大概率是本进程创建pipe，起了其他线程退出后，本进程没关掉。<br><img src="/2018/11/30/BugFromDFB/pipe.png" title="Use lsof and proc debug fd leak"><br>　　review code没发现不合理的pipe使用，于是通过strace查看是否有读写这个pipe的行为，来反推异常点。具体例子如下，我们先确认对应fd号，然后“strace -p $PID -e trace=open,close,rean,write”追读写行为。可惜事与愿违，没看到任何对新增pipe的读写操作，问题一度断线。不过仔细一想，异常时有调用DFBCreate的行为，而这部分通过DFB owner release so到工程中，我们看不到代码，故更应该从这里下手。通过实验确认如果没做这个行为就不会出现leak，也就是说可能是so中有地方创建线程，然后创建线程的地方没有close pipe导致leak，请owner review code中异常点，通过加log分析，确认是DFB中有地方逻辑异常导致问题的发生。<br><img src="/2018/11/30/BugFromDFB/strace.png" title="Use strace and proc debug fd leak"><br>　　至此，初测问题解决，但回头来看。异常发生时，只是因为fd leak导致DFB没法成功初始化，而我们实际只需要模块的抓图功能，不需要绘图功能，而DFB组件异常也不应该影响拉挂整个服务，即DFB异常时不应该通过exit退出。基于此改code，仅保留异常提示，然后返回异常值，上层做容错，增强系统稳定性。<br>　　提供修改给客户压测，压测后，发现问题现象依旧，但这次异常没有coredump了。幸运的是有tombstone文件，发现是挂在pthread_setschedparam上，具体如下。这次我跟owner要到代码了，通过review code可以确认param非NULL，那异常就应该是thread参数了，owner怀疑是pthread_create failed了，导致thread为0继而出现异常。</p><blockquote><p>int pthread_setschedparam(pthread_t thread, int policy,const struct sched_param *param);</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">334864</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /applications/bin/XXXX(_Z13signalHandleriP9siginfo_tPv+<span class="number">0xa4</span>) </span><br><span class="line"><span class="number">334865</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /lib/libc.so<span class="number">.6</span>(__default_rt_sa_restorer_v2+<span class="number">0</span>) </span><br><span class="line"><span class="number">334866</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /lib/libpthread.so<span class="number">.0</span>(pthread_getschedparam+<span class="number">0x4</span>) </span><br><span class="line"><span class="number">334867</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirect<span class="number">-1.4</span>.so<span class="number">.0</span>(direct_thread_create+<span class="number">0x18d</span>) </span><br><span class="line"><span class="number">334868</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/directfb<span class="number">-1.4</span><span class="number">-0</span>/inputdrivers/libdirectfb_mstarir.so(+<span class="number">0x15b4</span>) </span><br><span class="line"><span class="number">334869</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirectfb<span class="number">-1.4</span>.so<span class="number">.0</span>(+<span class="number">0x9b22a</span>) </span><br><span class="line"><span class="number">334870</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirectfb<span class="number">-1.4</span>.so<span class="number">.0</span>(dfb_core_part_initialize+<span class="number">0xa5</span>) </span><br><span class="line"><span class="number">334871</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirectfb<span class="number">-1.4</span>.so<span class="number">.0</span>(+<span class="number">0x90204</span>)</span><br><span class="line"><span class="number">334872</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libfusion<span class="number">-1.4</span>.so<span class="number">.0</span>(fusion_arena_enter+<span class="number">0x173</span>) </span><br><span class="line"><span class="number">334873</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirectfb<span class="number">-1.4</span>.so<span class="number">.0</span>(dfb_core_create+<span class="number">0x26b</span>) </span><br><span class="line"><span class="number">334874</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /mslib/libdirectfb<span class="number">-1.4</span>.so<span class="number">.0</span>(DirectFBCreate+<span class="number">0x21f</span>)</span><br><span class="line"><span class="number">334875</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /applications/bin/XXXX(MI_ATOM_XXX_Init+<span class="number">0x27c</span>)</span><br><span class="line"><span class="number">334876</span><span class="number">-01</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">21</span>:<span class="number">54.114</span>  <span class="number">2049</span>  <span class="number">2049</span> I XXXX:  /applications/bin/XXXX(MI_IMPL_XXX_Init+<span class="number">0x2ec</span>)</span><br></pre></td></tr></table></figure><p>　　通过加log压测，确认异常时pthread_create的返回值为EAGAIN （11），通过<a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=PTHREAD_CREATE(3)" title="pthread_create" target="_blank" rel="noopener">Linux Programmer’s Manual</a> pthread_create一节可以看到对这个返回值的解析，也就是线程创建数超限了，因此执行pthread_create创建新线程时，就会异常退出。</p><blockquote><p>EAGAIN Insufficient resources to create another thread.<br>EAGAIN A system-imposed limit on the number of threads was encountered.There are a number of limits that may trigger this error: the RLIMIT_NPROC soft resource limit (set via    setrlimit(2)),    which limits the number of processes and threads for a real user ID, was reached; the kernel’s system-wide limit on the number of processes and threads, /proc/sys/kernel/threads-max, was reached (see proc(5)); or the maximum number of    PIDs,    /proc/sys/kernel/pid_max, was reached (see proc(5)).</p></blockquote><p>　　手动复现问题，然后通过”busybox ps -T &gt; ps_t_$CNT.txt”，查看系统内全部进程线程信息，记录压测过程中相关变化，经过几次操作，发现每次都有两个dfb线程创建后没退出。长此以往，压测一段时间就会出现线程超限问题。因线程有通过prctl(PR_SET_NAME, “ThreadName1”); 设置线程名，也就很快定位问题点，review code后修正异常逻辑，重新手动测试，问题修正。<br><img src="/2018/11/30/BugFromDFB/threadLeak.png" title="abnormal thread create"></p><h3 id="FD-leak-debug手段"><a href="#FD-leak-debug手段" class="headerlink" title=" FD leak debug手段 "></a><span id="fd-leak-debug-method"> FD leak debug手段 </span></h3><h4 id="一-定位leak的是什么"><a href="#一-定位leak的是什么" class="headerlink" title="一. 定位leak的是什么"></a>一. 定位leak的是什么</h4><p>　　1、确认异常的PID。异常发生时，我们常会看到“Too many open files”这样的log，根据log所在PID的，或者其他手段我们可以确认异常发生的进程。<br>　　2、查看异常进程的FD信息。如果有复现手段，我们可以先执行”ls -la /proc/$PID/fd | grep . -c”，然后复现，统计异常操作前后FD数的变化情况，以此确认问题。确认异常后，就在异常操作前后分别”ls -la /proc/$PID/fd”，比较差异，获取leak的FD，如果有具体的设备名/文件名，我们可以直接全局搜索，查找是哪里open了，没释放。如果是匿名的管道和内存，那就需要进一步定位的。</p><h4 id="二-定位是哪里打开"><a href="#二-定位是哪里打开" class="headerlink" title="二. 定位是哪里打开"></a>二. 定位是哪里打开</h4><p>　　3、通过lsof大致定位异常发生情形。”lsof | grep -Ei $FD”，这个命令可以看到是哪些进程在用fd，尤其是pipe leak的分析，这个有一定的助益。本例中，大概定位是创建线程方没有close pipe。<br>　　4、strace定位操作行为。通过步骤2，我们可以获取到泄漏的fd号，配合“strace -p $PID -e trace=open,close,rean,write”，我们可以明确这个泄漏的pipe做了些什么，助攻问题定位。</p><h4 id="三-确认异常逻辑并修正"><a href="#三-确认异常逻辑并修正" class="headerlink" title="三. 确认异常逻辑并修正"></a>三. 确认异常逻辑并修正</h4><p>　　5、在有如上信息后，review code中相关flow，主要在于确认对应环境和情景下，为何会出现open没有close的行为。包括”anon_inode:[eventpoll]”和”/dev/ashmem”在内的诸多泄漏问题，都是对应场景下的考虑不周导致异常发生。各类leak的处理点难点也就在这里，定位的异常发生点，接下来要考虑的就是flow的问题了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这个问题发生在DFB相关资源不断申请和释放，每用一次就申请一次释放一次，因此对某个行为的压测就变成对DFB稳定的压测，从而使得问题暴露。实际上，DFB的资源申请只需要开机后做一次，此后其他进程使用这个服务的资源时，直接调用即可，这样整个系统的稳定性就会提升。另外，在这次debug过程中，我们可以看到没有做好各种防御编程，导致异常发生并恶化。<br><img src="/2018/11/30/BugFromDFB/abnormalCheck.png" title="abnormal thread usage"><br>　　任何时候，我们都不应该相信其他函数返回的结果，也不能假设库函数的返回结果是正常，始终坚持在防御代价比较低的情况下对各种场景做异常检测和防御，这是对软件稳定性的负责任。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本周处理的诸多问题中有两个是串联起来的，都是DFB相关的问题，一个是FD Leak，一个是创建线程没退出，这两个问题的处理过程本不是很复杂，常规手段即可处理，但这次debug过程中，暴露出一些coding上的问题，也是一个提醒。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="gdb" scheme="https://donald-zhuang.github.io/tags/gdb/"/>
    
      <category term="mprotect" scheme="https://donald-zhuang.github.io/tags/mprotect/"/>
    
      <category term="efence" scheme="https://donald-zhuang.github.io/tags/efence/"/>
    
      <category term="内存越界访问" scheme="https://donald-zhuang.github.io/tags/%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>内存异常处理手段总汇 一 -- electric-fence及其源码解析</title>
    <link href="https://donald-zhuang.github.io/2018/11/24/efence/"/>
    <id>https://donald-zhuang.github.io/2018/11/24/efence/</id>
    <published>2018-11-24T14:10:04.000Z</published>
    <updated>2018-11-24T18:22:14.577Z</updated>
    
    <content type="html"><![CDATA[<p>　　内存越界类问题都不太好搞，但也充满乐趣，有如侦探抽丝剥茧般。因为处理过好些这类问题，也就有想法将这些手段总汇起来，建立成一个辑录供参考。实际第一篇早已做出，即<a href="https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/">GCC SSP Canary功能简介</a>一篇，这也就是第二篇了。从electric-fence开始主要因其代码简单，一来方便阅读，二来方便自己修改优化。小工具用好即为神器，会用然后再做修改，便能顺心随意。本文最后的总结也提及一个修改tcmalloc实现自己需求的团队例子，器终归是器，用的人才是决定其价值的关键。<br><a id="more"></a></p><hr><p>　　<a href="https://github.com/CheggEng/electric-fence/tree/master" title="Electric-Fence Githubs" target="_blank" rel="noopener">electric-fence</a> 是一款malloc类函数内存调试工具，主要通过mprotect对memalign、malloc、free、valloc、calloc、strndup、strdup、realloc等函数进行重写，实现越界防护检测机制。这个实现也就决定其只能用于内存越界访问行为debug，没法检测内存泄漏，也无法准确定位C++中new, new[], delete, delete[]的问题（但可以大概定位）。想起曾有大佬让我用efence查内存泄漏，而且还是对象泄漏问题…<br>　　efence的核心实现由initialize、memalign、free组成，捋顺这三个，整个工作机制也就打通了。</p><h3 id="通过LD-PRELOAD和GDB使用eFence"><a href="#通过LD-PRELOAD和GDB使用eFence" class="headerlink" title="通过LD_PRELOAD和GDB使用eFence"></a>通过LD_PRELOAD和GDB使用eFence</h3><p>　　如果你只想了解最核心的原理，可以直接通过本文<a href="#allocator-realization">memalign实现 – allocator核心</a>一节了解，然后直接参考<a href="https://xsyr.github.io/%E7%BC%96%E7%A8%8B/c/c++/2013/10/13/use-electric-fence-to-detect-heap-overruns-and-underruns.html" title="使用efence检测内存泄漏问题" target="_blank" rel="noopener">使用efence检测内存泄漏问题</a>这篇文章就可顺溜地使用efence了。这里也补充介绍两种debug方式：LD_PRELOAD和GDB。<br>　　如果是已经编译好但未链接libefence的bin档，我们可以通过”LD_PRELOAD=./libefence.so bin”来预加载libefence.so再执行bin，实现efence符号对libc中malloc符号的覆盖。<br>　　gdb需在.gdbinit增加如下代码，也可以在此基础上也可增加你需要的配置（具体参考<a href="https://linux.die.net/man/3/efence" title="efence用法" target="_blank" rel="noopener">efence - Linux man page</a>介绍）。然后在debug对应程序时，执行efence on即可开启对应功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define efence</span><br><span class="line">        <span class="built_in">set</span> environment EF_ALLOW_MALLOC_0 <span class="number">0</span></span><br><span class="line">        <span class="built_in">set</span> environment LD_PRELOAD /usr/lib/libefence.so<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        echo Enabled eFence\n</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="initialize函数-–-配置库运行功能和创建内存索引"><a href="#initialize函数-–-配置库运行功能和创建内存索引" class="headerlink" title="initialize函数 – 配置库运行功能和创建内存索引"></a>initialize函数 – 配置库运行功能和创建内存索引</h3><p>　　顾名思义，initialize函数完成整个库的初始化和环境配置工作。其实现主要分为两部分，第一部分是通过环境变量获取各项功能开关设置，第二部分是申请一块不小于1M的内存并配置相关数据结构。</p><h4 id="功能开关配置"><a href="#功能开关配置" class="headerlink" title="功能开关配置"></a>功能开关配置</h4><p>　　使能对应功能，首先需要code中配置对应变量为-1，然后通过同名环境变量来实现对对应功能的开关，相关变量大概说明如下。</p><blockquote><ol><li>EF_DISABLE_BANNER:是否打印库版本信息</li><li>EF_ALIGNMENT:Efence malloc分配空间的内存对齐字节数，默认值为sizeof(int)，这个值也是Efence能够检测的内存越界的最小值。</li><li>EF_PROTECT_BELOW：默认情况下，efence检测是高地址越界问题，若将此值设置为1，则表示检测内存低地址越界问题。</li><li>EF_PROTECT_FREE：使能use after free检测。</li><li>EF_ALLOW_MALLOC_0：是否检查malloc(0)行为</li><li>EF_FREE_WIPES：free内存后，是否对该区域填充0xbd</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialize sets up the memory allocation arena and the run-time</span></span><br><span class="line"><span class="comment"> * configuration information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initialize(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 功能说明和配置 */</span></span><br><span class="line">       <span class="keyword">if</span> ( EF_DISABLE_BANNER == <span class="number">-1</span> ) &#123;</span><br><span class="line">               <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_DISABLE_BANNER"</span>)) != <span class="number">0</span> )</span><br><span class="line">                       EF_DISABLE_BANNER = atoi(<span class="built_in">string</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                       EF_DISABLE_BANNER = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ( EF_DISABLE_BANNER == <span class="number">0</span> )</span><br><span class="line">               EF_Print(version); <span class="comment">// 打印efence库版本信息</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Import the user's environment specification of the default</span></span><br><span class="line"><span class="comment">  * alignment for malloc(). We want that alignment to be under</span></span><br><span class="line"><span class="comment">  * user control, since smaller alignment lets us catch more bugs,</span></span><br><span class="line"><span class="comment">  * however some software will break if malloc() returns a buffer</span></span><br><span class="line"><span class="comment">  * that is not word-aligned.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * I would like</span></span><br><span class="line"><span class="comment">  * alignment to be zero so that we could catch all one-byte</span></span><br><span class="line"><span class="comment">  * overruns, however if malloc() is asked to allocate an odd-size</span></span><br><span class="line"><span class="comment">  * buffer and returns an address that is not word-aligned, or whose</span></span><br><span class="line"><span class="comment">  * size is not a multiple of the word size, software breaks.</span></span><br><span class="line"><span class="comment">  * This was the case with the Sun string-handling routines,</span></span><br><span class="line"><span class="comment">  * which can do word fetches up to three bytes beyond the end of a</span></span><br><span class="line"><span class="comment">  * string. I handle this problem in part by providing</span></span><br><span class="line"><span class="comment">  * byte-reference-only versions of the string library functions, but</span></span><br><span class="line"><span class="comment">  * there are other functions that break, too. Some in X Windows, one</span></span><br><span class="line"><span class="comment">  * in Sam Leffler's TIFF library, and doubtless many others.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 内存对齐配置： 如上面英文注释介绍，这里配置的是malloc的内存对齐颗粒度，</span></span><br><span class="line"><span class="comment">     * 原理上，取值越小能够捕捉到更多非法访问行为，但也会导致malloc返回的</span></span><br><span class="line"><span class="comment">     * 内存地址不是字对齐的，会导致部分软件运行异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="keyword">if</span> ( EF_ALIGNMENT == <span class="number">-1</span> ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_ALIGNMENT"</span>)) != <span class="number">0</span> )</span><br><span class="line">   EF_ALIGNMENT = (<span class="keyword">size_t</span>)atoi(<span class="built_in">string</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   EF_ALIGNMENT = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * See if the user wants to protect the address space below a buffer,</span></span><br><span class="line"><span class="comment">  * rather than that above a buffer.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 保护buffer的高地址还是低地址的选项开关，即检测内存低地址越界，还是高地址越界问题 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="keyword">if</span> ( EF_PROTECT_BELOW == <span class="number">-1</span> ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_PROTECT_BELOW"</span>)) != <span class="number">0</span> )</span><br><span class="line">   EF_PROTECT_BELOW = (atoi(<span class="built_in">string</span>) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   EF_PROTECT_BELOW = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * See if the user wants to protect memory that has been freed until</span></span><br><span class="line"><span class="comment">  * the program exits, rather than until it is re-allocated.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * use after free检测功能开关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="keyword">if</span> ( EF_PROTECT_FREE == <span class="number">-1</span> ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_PROTECT_FREE"</span>)) != <span class="number">0</span> )</span><br><span class="line">   EF_PROTECT_FREE = (atoi(<span class="built_in">string</span>) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   EF_PROTECT_FREE = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * See if the user wants to allow malloc(0).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> ( EF_ALLOW_MALLOC_0 == <span class="number">-1</span> ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_ALLOW_MALLOC_0"</span>)) != <span class="number">0</span> )</span><br><span class="line">   EF_ALLOW_MALLOC_0 = (atoi(<span class="built_in">string</span>) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   EF_ALLOW_MALLOC_0 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * See if the user wants us to wipe out freed memory.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">if</span> ( EF_FREE_WIPES == <span class="number">-1</span> ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( (<span class="built_in">string</span> = getenv(<span class="string">"EF_FREE_WIPES"</span>)) != <span class="number">0</span> )</span><br><span class="line">                 EF_FREE_WIPES = (atoi(<span class="built_in">string</span>) != <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">                 EF_FREE_WIPES = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内存申请和初始化操作，具体见下节分析 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Initialize的内存操作部分"><a href="#Initialize的内存操作部分" class="headerlink" title="Initialize的内存操作部分"></a>Initialize的内存操作部分</h4><p>　　Initialize的内存操作主要实现流程如下：</p><blockquote><ol><li>第一次申请内存时，通过mmap向操作系统申请不少于MEMORY_CREATION_SIZE字节内存，code中设定为1MB，该值实际会自动向上取最小满足页对齐的大小。</li><li>申请到的内存第一页用于存放slot结构体数组。slot用于管理被分配的各个内存单元信息,如返回给用户的实际地址、内部实际地址、大小等，具体如下。</li><li>slot[0]用于存放slot结构体数组起始地址和当前数组大小的信息。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Slot</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span> *userAddress; <span class="comment">// 返回给用户的实际地址</span></span><br><span class="line"> <span class="keyword">void</span> *internalAddress; <span class="comment">// 实际内存区起始地址</span></span><br><span class="line"> <span class="keyword">size_t</span>userSize; <span class="comment">// 用户申请的大小</span></span><br><span class="line"> <span class="keyword">size_t</span>internalSize; <span class="comment">// 内部实际申请的大小</span></span><br><span class="line"> Modemode; <span class="comment">// 节点对应的模式，具体如下</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> _Mode &#123;</span><br><span class="line"> NOT_IN_USE = <span class="number">0</span>,<span class="comment">/* Available to represent a malloc buffer. */</span></span><br><span class="line"> FREE,<span class="comment">/* A free buffer. */</span></span><br><span class="line"> ALLOCATED,<span class="comment">/* A buffer that is in use. */</span></span><br><span class="line"> PROTECTED,<span class="comment">/* A freed buffer that can not be allocated again. */</span></span><br><span class="line"> INTERNAL_USE<span class="comment">/* A buffer used internally by malloc(). */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<br>代码解析如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span>  size = MEMORY_CREATION_SIZE; <span class="comment">//  MEMORY_CREATION_SIZE = 1024*1024;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the run-time configuration of the virtual memory page size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 获取当前虚拟内存页大小</span></span><br><span class="line">bytesPerPage = Page_Size(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Figure out how many Slot structures to allocate at one time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 计算一个页可以存储多少个slot结构</span></span><br><span class="line">slotCount = slotsPerPage = bytesPerPage / <span class="keyword">sizeof</span>(Slot); </span><br><span class="line">allocationListSize = bytesPerPage;</span><br><span class="line"><span class="keyword">if</span> ( allocationListSize &gt; size )</span><br><span class="line">    size = allocationListSize; <span class="comment">// 若页大于1M，则申请内存的大小扩展为页大小</span></span><br><span class="line"><span class="keyword">if</span> ( (slack = size % bytesPerPage) != <span class="number">0</span> )</span><br><span class="line">    size += bytesPerPage - slack;  <span class="comment">// 将申请的内存以页大小对齐</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate memory, and break it up into two malloc buffers. The</span></span><br><span class="line"><span class="comment"> * first buffer will be used for Slot structures, the second will</span></span><br><span class="line"><span class="comment"> * be marked free.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 通过mmap创建N * bytesPerPage大小的内存</span></span><br><span class="line">slot = allocationList = (Slot *)Page_Create(size); </span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)allocationList, <span class="number">0</span>, allocationListSize);</span><br><span class="line">    <span class="comment">// 申请的内存第一页用于存放slot结构数组，这一页的信息记录于slot[0]</span></span><br><span class="line">    <span class="comment">// eFence中allocateMoreSlots没有更新这个结构体的信息，算是个bug吧？</span></span><br><span class="line">slot[<span class="number">0</span>].internalSize = slot[<span class="number">0</span>].userSize = allocationListSize;</span><br><span class="line">slot[<span class="number">0</span>].internalAddress = slot[<span class="number">0</span>].userAddress = allocationList;</span><br><span class="line">slot[<span class="number">0</span>].mode = INTERNAL_USE;</span><br><span class="line">    <span class="comment">// 当申请size大于一页，则剩余部分作为用户内存预留下来。</span></span><br><span class="line"><span class="keyword">if</span> ( size &gt; allocationListSize ) &#123;</span><br><span class="line">    slot[<span class="number">1</span>].internalAddress = slot[<span class="number">1</span>].userAddress</span><br><span class="line">     = ((<span class="keyword">char</span> *)slot[<span class="number">0</span>].internalAddress) + slot[<span class="number">0</span>].internalSize;</span><br><span class="line">    slot[<span class="number">1</span>].internalSize</span><br><span class="line">     = slot[<span class="number">1</span>].userSize = size - slot[<span class="number">0</span>].internalSize;</span><br><span class="line">    slot[<span class="number">1</span>].mode = FREE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deny access to the free page, so that we will detect any software</span></span><br><span class="line"><span class="comment"> * that treads upon free memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// mprotect将刚申请的内存部分设置为PROT_NONE，防止非法读写行为</span></span><br><span class="line">     <span class="comment">// 实际，slot[0]对应的那块内存也要保护的，但没有，暂未发现会导致什么问题。</span></span><br><span class="line">Page_DenyAccess(slot[<span class="number">1</span>].internalAddress, slot[<span class="number">1</span>].internalSize);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Account for the two slot structures that we've used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 消耗了两个slot，因此计数计数减一，efence中Hardcode了当unUsedSlots &lt; 7时</span></span><br><span class="line">    <span class="comment">// 需要重新在这个基础上申请多一个页来存放新的slot</span></span><br><span class="line">unUsedSlots = slotCount - <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h3 id="memalign函数-–-allocator核心"><a href="#memalign函数-–-allocator核心" class="headerlink" title=" memalign函数 – allocator核心 "></a><span id="allocator-realization"> memalign函数 – allocator核心 </span></h3><p>　　memalign是整个efence的核心部分，所申请的内存块都是以页为单位（受限于mprotect），其取值为最小满足用户申请的内存大小的页数再加一，多加的这一页就是eFence工作的根本。如下例子中，用户申请的内存小于一页，而memalign实际申请了两页内存。</p><blockquote><ol><li>当EF_PROTECT_BELOW为0、查高地址越界访问时，allocator会设置Page 1为PROT_NONE，Page 0为RW，然后Page 1的起始地址addr - sizeof(Variables)即为返回的地址（落在Page0中）。</li><li>当EF_PROTECT_BELOW非0、查低地址越界访问时，Page 0会被设置为PROT_NONE，Page 1起始地址为返回地址。</li><li>完成如上设置，当出现内存越界访问时，就会对PROTECTED区域进行读写，导致页错误而coredump，这也就是efence实现的原理了。</li></ol></blockquote><img src="/2018/11/24/efence/efence.png" title="realization of efence"><p>　　memalign函数的具体实现分为下面几步，显然，在大量申请小内存的场景中，efence如果没有及时释放申请的内存，内存将会严重碎片化。</p><blockquote><ol><li>对用户申请内存的大小做预处理。检查是否malloc(0)-&gt;按函参alignment大小对齐-&gt;增加1个页的大小，然后取最小满足该内存大小的最小页数（即internalSize）</li><li>查询空闲的slot用于记录本次申请。如果当前未使用的slot数小于7，申请一块大slot数组一个页的内存，扩展slot数组。</li><li>内存分配，从slot数组FREE的记录中查找满足internalSize的内存，最终可分为如下三种case：<blockquote><p>1)刚好有一块大小满足internalSize的内存，直接使用；<br>2)有不少于一块大于申请大小的内存。选取最小的一块，将这块内存分割为两部分，一部分作为结果返回给用户，剩余部分用一个NOT_IN_USE的slot记录供下次申请；<br>3)所有记录都小于申请的大小。重新申请一块不小于1M且页对齐的内存，并用一个空闲的slot（NOT_IN_USE）记录下来，然后执行第2个case的操作。</p></blockquote></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the memory allocator. When asked to allocate a buffer, allocate</span></span><br><span class="line"><span class="comment"> * it in such a way that the end of the buffer is followed by an inaccessable</span></span><br><span class="line"><span class="comment"> * memory page. If software overruns that buffer, it will touch the bad page</span></span><br><span class="line"><span class="comment"> * and get an immediate segmentation fault. It's then easy to zero in on the</span></span><br><span class="line"><span class="comment"> * offending code with a debugger.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are a few complications. If the user asks for an odd-sized buffer,</span></span><br><span class="line"><span class="comment"> * we would have to have that buffer start on an odd address if the byte after</span></span><br><span class="line"><span class="comment"> * the end of the buffer was to be on the inaccessable page. Unfortunately,</span></span><br><span class="line"><span class="comment"> * there is lots of software that asks for odd-sized buffers and then</span></span><br><span class="line"><span class="comment"> * requires that the returned address be word-aligned, or the size of the</span></span><br><span class="line"><span class="comment"> * buffer be a multiple of the word size. An example are the string-processing</span></span><br><span class="line"><span class="comment"> * functions on Sun systems, which do word references to the string memory</span></span><br><span class="line"><span class="comment"> * and may refer to memory up to three bytes beyond the end of the string.</span></span><br><span class="line"><span class="comment"> * For this reason, I take the alignment requests to memalign() and valloc()</span></span><br><span class="line"><span class="comment"> * seriously, and</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Electric Fence wastes lots of memory. I do a best-fit allocator here</span></span><br><span class="line"><span class="comment"> * so that it won't waste even more. It's slow, but thrashing because your</span></span><br><span class="line"><span class="comment"> * working set is too big for a system's RAM is even slower.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> C_LINKAGE <span class="keyword">void</span> *</span><br><span class="line">memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> userSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> Slot * slot;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">size_t</span> count;</span><br><span class="line">    Slot *      fullSlot = <span class="number">0</span>;</span><br><span class="line">    Slot *      emptySlots[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span>      internalSize;</span><br><span class="line">    <span class="keyword">size_t</span>      slack;</span><br><span class="line">    <span class="keyword">char</span> *      address;</span><br><span class="line">    <span class="keyword">if</span> ( allocationList == <span class="number">0</span> )</span><br><span class="line">        initialize();</span><br><span class="line">    <span class="comment">// EF_ALLOW_MALLOC_0为0时开启malloc(0)检查</span></span><br><span class="line">    <span class="keyword">if</span> ( userSize == <span class="number">0</span> &amp;&amp; !EF_ALLOW_MALLOC_0 )</span><br><span class="line">        EF_Abort(<span class="string">"Allocating 0 bytes, probably a bug."</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If EF_PROTECT_BELOW is set, all addresses returned by malloc()</span></span><br><span class="line"><span class="comment">     * and company will be page-aligned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     *   如果未开启低地址越界保护，则需要做内存对齐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( !EF_PROTECT_BELOW &amp;&amp; alignment &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (slack = userSize % alignment) != <span class="number">0</span> )</span><br><span class="line">            userSize += alignment - slack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The internal size of the buffer is rounded up to the next page-size</span></span><br><span class="line"><span class="comment">     * boudary, and then we add another page's worth of memory for the</span></span><br><span class="line"><span class="comment">     * dead page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 将用户申请的大小调整到如下数量的页</span></span><br><span class="line"><span class="comment">      * (userSize / bytesPerPage) + (int)(userSize % bytesPerPage != 0) 页</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    internalSize = userSize + bytesPerPage;</span><br><span class="line">    <span class="keyword">if</span> ( (slack = internalSize % bytesPerPage) != <span class="number">0</span> )</span><br><span class="line">        internalSize += bytesPerPage - slack;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These will hold the addresses of two empty Slot structures, that</span></span><br><span class="line"><span class="comment">     * can be used to hold information for any memory I create, and any</span></span><br><span class="line"><span class="comment">     * memory that I mark free.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 准备记录两个NOT_IN_USE的slot，主要应对上面提及的case 2和case 3</span></span><br><span class="line"><span class="comment">     * case 2：emptySlots[0]记录分配给用户后，剩余的那块内存（FREE）。</span></span><br><span class="line"><span class="comment">     * case 3: emptySlots[0]记录新申请的内存，emptySlots[1]执行case 2中的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     emptySlots[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     emptySlots[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The internal memory used by the allocator is currently</span></span><br><span class="line"><span class="comment">     * inaccessable, so that errant programs won't scrawl on the</span></span><br><span class="line"><span class="comment">     * allocator's arena. I'll un-protect it here so that I can make</span></span><br><span class="line"><span class="comment">     * a new allocation. I'll re-protect it before I return.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( !noAllocationListProtection )</span><br><span class="line">        Page_AllowAccess(allocationList, allocationListSize);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If I'm running out of empty slots, create some more before</span></span><br><span class="line"><span class="comment">     * I don't have enough slots left to make an allocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果当前未使用的slot少于7个，则需要申请多一个页来扩展slot数组以满足后续</span></span><br><span class="line"><span class="comment">     * 使用，internalUse是用来防重入的，因memalign -&gt; allocateMoreSlots-&gt;</span></span><br><span class="line"><span class="comment">     * internalUse = 1; -&gt; malloc -&gt; memalign，如果不做这判断就会重入爆栈。</span></span><br><span class="line"><span class="comment">     * 这里通过malloc来做会占用多一个页，造成浪费，这也就有一个优化点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( !internalUse &amp;&amp; unUsedSlots &lt; <span class="number">7</span> ) &#123;</span><br><span class="line">        allocateMoreSlots();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Iterate through all of the slot structures. Attempt to find a slot</span></span><br><span class="line"><span class="comment">     * containing free memory of the exact right size. Accept a slot with</span></span><br><span class="line"><span class="comment">     * more memory than we want, if the exact right size is not available.</span></span><br><span class="line"><span class="comment">     * Find two slot structures that are not in use. We will need one if</span></span><br><span class="line"><span class="comment">     * we split a buffer into free and allocated parts, and the second if</span></span><br><span class="line"><span class="comment">     * we have to create new memory and mark it as free.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 遍历slot数组，查找FREE slot中是否有一块不小于所需的内存，循环的终止条件为</span></span><br><span class="line"><span class="comment">     * 1) 找到恰好满足所需大小内存的FREE slot和一个NOT_IN_USE slot；</span></span><br><span class="line"><span class="comment">     * 2) 找不到恰好满足的大小，但找到两个NOT_IN_USE的slot</span></span><br><span class="line"><span class="comment">     * 满足一个即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> ( slot = allocationList, count = slotCount ; count &gt; <span class="number">0</span>; count-- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( slot-&gt;mode == FREE</span><br><span class="line">         &amp;&amp; slot-&gt;internalSize &gt;= internalSize ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !fullSlot</span><br><span class="line">             ||slot-&gt;internalSize &lt; fullSlot-&gt;internalSize)&#123;</span><br><span class="line">                fullSlot = slot;</span><br><span class="line">                <span class="keyword">if</span> ( slot-&gt;internalSize == internalSize</span><br><span class="line">                 &amp;&amp; emptySlots[<span class="number">0</span>] )</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">/* All done, */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( slot-&gt;mode == NOT_IN_USE ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !emptySlots[<span class="number">0</span>] )</span><br><span class="line">                emptySlots[<span class="number">0</span>] = slot;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( !emptySlots[<span class="number">1</span>] )</span><br><span class="line">                emptySlots[<span class="number">1</span>] = slot;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( fullSlot</span><br><span class="line">             &amp;&amp; fullSlot-&gt;internalSize == internalSize )</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">/* All done. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        slot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !emptySlots[<span class="number">0</span>] )</span><br><span class="line">        internalError();</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果通过第2个条件退出循环，且没找到一个不小于申请所需大小的内存，</span></span><br><span class="line"><span class="comment">     * 则申请一块不小于1M大小的内存，使用emptySlots[0]记录该buffer信息，</span></span><br><span class="line"><span class="comment">     * 然后将emptySlots[0]指向emptySlots[1]，供后续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( !fullSlot ) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * I get here if I haven't been able to find a free buffer</span></span><br><span class="line"><span class="comment">         * with all of the memory I need. I'll have to create more</span></span><br><span class="line"><span class="comment">         * memory. I'll mark it all as free, and then split it into</span></span><br><span class="line"><span class="comment">         * free and allocated portions later.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">size_t</span>  chunkSize = MEMORY_CREATION_SIZE;</span><br><span class="line">        <span class="keyword">if</span> ( !emptySlots[<span class="number">1</span>] )</span><br><span class="line">            internalError();</span><br><span class="line">        <span class="keyword">if</span> ( chunkSize &lt; internalSize )</span><br><span class="line">            chunkSize = internalSize;</span><br><span class="line">        <span class="keyword">if</span> ( (slack = chunkSize % bytesPerPage) != <span class="number">0</span> )</span><br><span class="line">            chunkSize += bytesPerPage - slack;</span><br><span class="line">        <span class="comment">/* Use up one of the empty slots to make the full slot. */</span></span><br><span class="line">        fullSlot = emptySlots[<span class="number">0</span>];</span><br><span class="line">        emptySlots[<span class="number">0</span>] = emptySlots[<span class="number">1</span>];</span><br><span class="line">        fullSlot-&gt;internalAddress = Page_Create(chunkSize);</span><br><span class="line">        fullSlot-&gt;internalSize = chunkSize;</span><br><span class="line">        fullSlot-&gt;mode = FREE;</span><br><span class="line">        unUsedSlots--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If I'm allocating memory for the allocator's own data structures,</span></span><br><span class="line"><span class="comment">     * mark it INTERNAL_USE so that no errant software will be able to</span></span><br><span class="line"><span class="comment">     * free it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( internalUse )</span><br><span class="line">        fullSlot-&gt;mode = INTERNAL_USE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fullSlot-&gt;mode = ALLOCATED;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the buffer I've found is larger than I need, split it into</span></span><br><span class="line"><span class="comment">     * an allocated buffer with the exact amount of memory I need, and</span></span><br><span class="line"><span class="comment">     * a free buffer containing the surplus memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查如上获取到的内存大小是否大于所需，若大于所需，则通过emptySlots[0]</span></span><br><span class="line"><span class="comment">     * 将多余部分记录下来，供下次申请使用，这个也是作者避免内存浪费的一个优化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( fullSlot-&gt;internalSize &gt; internalSize ) &#123;</span><br><span class="line">        emptySlots[<span class="number">0</span>]-&gt;internalSize</span><br><span class="line">         = fullSlot-&gt;internalSize - internalSize;</span><br><span class="line">        emptySlots[<span class="number">0</span>]-&gt;internalAddress</span><br><span class="line">         = ((<span class="keyword">char</span> *)fullSlot-&gt;internalAddress) + internalSize;</span><br><span class="line">        emptySlots[<span class="number">0</span>]-&gt;mode = FREE;</span><br><span class="line">        fullSlot-&gt;internalSize = internalSize;</span><br><span class="line">        unUsedSlots--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现保护的算法部分，也就是文字说明画的那个图，下面我也会给个文字图。</span></span><br><span class="line">    <span class="keyword">if</span> ( !EF_PROTECT_BELOW ) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Arrange the buffer so that it is followed by an inaccessable</span></span><br><span class="line"><span class="comment">         * memory page. A buffer overrun that touches that page will</span></span><br><span class="line"><span class="comment">         * cause a segmentation fault.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/* 算法实现如下内存分布。当内存往高地址越界时，就会触发页错误导致coredump，</span></span><br><span class="line"><span class="comment">          也可见，用户申请的内存（MemForUser）越小，内存浪费越严重。</span></span><br><span class="line"><span class="comment">      low      +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       |       |   WastedMem   |                 |</span></span><br><span class="line"><span class="comment">       |       +---------------+       page1     |</span></span><br><span class="line"><span class="comment">       |       |   MemForUser  |                 |</span></span><br><span class="line"><span class="comment">       |       +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       |       |   PROT_NONE   |       page2     |</span></span><br><span class="line"><span class="comment">      high     +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        address = (<span class="keyword">char</span> *)fullSlot-&gt;internalAddress;</span><br><span class="line">        <span class="comment">/* Set up the "live" page. */</span> <span class="comment">// page1 部分使能读写</span></span><br><span class="line">        <span class="keyword">if</span> ( internalSize - bytesPerPage &gt; <span class="number">0</span> )</span><br><span class="line">                Page_AllowAccess(</span><br><span class="line">                 fullSlot-&gt;internalAddress</span><br><span class="line">                ,internalSize - bytesPerPage);</span><br><span class="line">        address += internalSize - bytesPerPage;</span><br><span class="line">        <span class="comment">/* Set up the "dead" page. */</span> <span class="comment">// page2 禁止访写</span></span><br><span class="line">        Page_DenyAccess(address, bytesPerPage);</span><br><span class="line">        <span class="comment">/* Figure out what address to give the user. */</span></span><br><span class="line">        address -= userSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* EF_PROTECT_BELOW != 0 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Arrange the buffer so that it is preceded by an inaccessable</span></span><br><span class="line"><span class="comment">         * memory page. A buffer underrun that touches that page will</span></span><br><span class="line"><span class="comment">         * cause a segmentation fault.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/* 内存往低地址写的时候，会触及PROT_NONE部分内存，导致页错误，引发coredump</span></span><br><span class="line"><span class="comment">      low      +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       |       |   PROT_NONE   |      page2      |</span></span><br><span class="line"><span class="comment">       |       +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       |       |   MemForUser  |                 |</span></span><br><span class="line"><span class="comment">       |       +---------------+      page1      |</span></span><br><span class="line"><span class="comment">       |       |   WastedMem   |                 |</span></span><br><span class="line"><span class="comment">      high     +---------------+-----------------+</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        address = (<span class="keyword">char</span> *)fullSlot-&gt;internalAddress;</span><br><span class="line">        <span class="comment">/* Set up the "dead" page. */</span></span><br><span class="line">        Page_DenyAccess(address, bytesPerPage);</span><br><span class="line">        address += bytesPerPage;</span><br><span class="line">        <span class="comment">/* Set up the "live" page. */</span></span><br><span class="line">        <span class="keyword">if</span> ( internalSize - bytesPerPage &gt; <span class="number">0</span> )</span><br><span class="line">            Page_AllowAccess(address, internalSize - bytesPerPage);</span><br><span class="line">    &#125;</span><br><span class="line">    fullSlot-&gt;userAddress = address;</span><br><span class="line">    fullSlot-&gt;userSize = userSize;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make the pool's internal memory inaccessable, so that the program</span></span><br><span class="line"><span class="comment">     * being debugged can't stomp on it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( !internalUse )</span><br><span class="line">        Page_DenyAccess(allocationList, allocationListSize);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free函数-–-碎片化问题处理"><a href="#free函数-–-碎片化问题处理" class="headerlink" title="free函数 – 碎片化问题处理"></a>free函数 – 碎片化问题处理</h3><p>　　基本上，通过对memalign的解析，我们大概可以预想free的功能要怎么实现了。</p><blockquote><ol><li>如果开启EF_PROTECT_FREE，也就是UAF检测，则将slot-&gt;mode = PROTECTED，不再被使用，否则设置为FREE供后续使用</li><li>如果开启EF_FREE_WIPES，也就是poison memory的话，则将对应内存memset为0xbd</li><li>将free的内存区域mprotect为PROT_NONE</li></ol></blockquote><p>　　然后我没想到的是上面提及的内存碎片化，作者在这里做了处理，即在free时候尝试合并前后同类块以降低碎片化，不过看起来有bug。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> C_LINKAGE <span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> * address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Slot *  slot;</span><br><span class="line">    Slot *  previousSlot = <span class="number">0</span>;</span><br><span class="line">    Slot *  nextSlot = <span class="number">0</span>;</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span> ( address == <span class="number">0</span> ) &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( allocationList == <span class="number">0</span> )</span><br><span class="line">        EF_Abort(<span class="string">"free() called before first malloc()."</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !noAllocationListProtection )</span><br><span class="line">        Page_AllowAccess(allocationList, allocationListSize);</span><br><span class="line">    <span class="comment">// 查找对应地址的所在slot</span></span><br><span class="line">    slot = slotForUserAddress(address);</span><br><span class="line">    <span class="keyword">if</span> ( !slot )</span><br><span class="line">        EF_Abort(<span class="string">"free(%a): address not from malloc()."</span>, address);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  1) 如果是internalUse == 1，即allocateMoreSlots() -&gt; free()，则正常释放，</span></span><br><span class="line"><span class="comment">     *  不abort退出，如果internalUse == 0，且为INTERNAL_USE内存，说明有非法尝试</span></span><br><span class="line"><span class="comment">     *  释放库内部地址，此时应abort退出。</span></span><br><span class="line"><span class="comment">     *  2) 如果是非INTERNAL_USE且不为ALLOCATED则是double free，因为PROTECTED/FREE</span></span><br><span class="line"><span class="comment">     *  都是free后标记的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( slot-&gt;mode != ALLOCATED ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( internalUse &amp;&amp; slot-&gt;mode == INTERNAL_USE )</span><br><span class="line">            <span class="comment">/* Do nothing. */</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            EF_Abort(</span><br><span class="line">             <span class="string">"free(%a): freeing free memory."</span></span><br><span class="line">            ,address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( EF_PROTECT_FREE )</span><br><span class="line">        slot-&gt;mode = PROTECTED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        slot-&gt;mode = FREE;</span><br><span class="line">    <span class="keyword">if</span> ( EF_FREE_WIPES )</span><br><span class="line">      <span class="built_in">memset</span>(slot-&gt;userAddress, <span class="number">0xbd</span>, slot-&gt;userSize);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  这里是作者为降低内存碎片化做的努力。分别查找当前slot内存块前后的内存</span></span><br><span class="line"><span class="comment">     *  是否在记录内，如果存在且为PROTECT或FREE的内存，将slot对应内存合并，</span></span><br><span class="line"><span class="comment">     *  并释放其中一个slot结构体。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    previousSlot = slotForInternalAddressPreviousTo(slot-&gt;internalAddress);</span><br><span class="line">    nextSlot = slotForInternalAddress(</span><br><span class="line">     ((<span class="keyword">char</span> *)slot-&gt;internalAddress) + slot-&gt;internalSize);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * bug case: 如果mmap多次分配内存的地址是连续的，即previousSlot/nextSlot</span></span><br><span class="line"><span class="comment">     * 地址刚好与当前slot地址连续，但他们是FREE的，而当前slot的是PROTECTED的，</span></span><br><span class="line"><span class="comment">     * 那会导致未使用的内存被污染了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( previousSlot</span><br><span class="line">     &amp;&amp; (previousSlot-&gt;mode == FREE || previousSlot-&gt;mode == PROTECTED) ) &#123;</span><br><span class="line">        <span class="comment">/* Coalesce previous slot with this one. */</span></span><br><span class="line">        previousSlot-&gt;internalSize += slot-&gt;internalSize;</span><br><span class="line">        <span class="keyword">if</span> ( EF_PROTECT_FREE )</span><br><span class="line">            previousSlot-&gt;mode = PROTECTED;</span><br><span class="line">        slot-&gt;internalAddress = slot-&gt;userAddress = <span class="number">0</span>;</span><br><span class="line">        slot-&gt;internalSize = slot-&gt;userSize = <span class="number">0</span>;</span><br><span class="line">        slot-&gt;mode = NOT_IN_USE;</span><br><span class="line">        slot = previousSlot;</span><br><span class="line">        unUsedSlots++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( nextSlot</span><br><span class="line">     &amp;&amp; (nextSlot-&gt;mode == FREE || nextSlot-&gt;mode == PROTECTED) ) &#123;</span><br><span class="line">        <span class="comment">/* Coalesce next slot with this one. */</span></span><br><span class="line">        slot-&gt;internalSize += nextSlot-&gt;internalSize;</span><br><span class="line">        nextSlot-&gt;internalAddress = nextSlot-&gt;userAddress = <span class="number">0</span>;</span><br><span class="line">        nextSlot-&gt;internalSize = nextSlot-&gt;userSize = <span class="number">0</span>;</span><br><span class="line">        nextSlot-&gt;mode = NOT_IN_USE;</span><br><span class="line">        unUsedSlots++;</span><br><span class="line">    &#125;</span><br><span class="line">    slot-&gt;userAddress = slot-&gt;internalAddress;</span><br><span class="line">    slot-&gt;userSize = slot-&gt;internalSize;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Free memory is _always_ set to deny access. When EF_PROTECT_FREE</span></span><br><span class="line"><span class="comment">     * is true, free memory is never reallocated, so it remains access</span></span><br><span class="line"><span class="comment">     * denied for the life of the process. When EF_PROTECT_FREE is false,</span></span><br><span class="line"><span class="comment">     * the memory may be re-allocated, at which time access to it will be</span></span><br><span class="line"><span class="comment">     * allowed again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 保护FREE和PROTECT的内存，防止越界和UAF</span></span><br><span class="line">    Page_DenyAccess(slot-&gt;internalAddress, slot-&gt;internalSize);</span><br><span class="line">    <span class="keyword">if</span> ( !noAllocationListProtection )</span><br><span class="line">        Page_DenyAccess(allocationList, allocationListSize);</span><br><span class="line">        unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　经过如上分析，我们可以发现efence并不是很完善，还有一些优化的空间。另外他也有如下局限性，</p><blockquote><p>1、malloc和free在slot都是线性查找，复杂度为O(n)，性能较低。<br>2、内存消耗大，特别对于频繁的小内存分配，每次至少申请两个页，内存利用率低。<br>3、无法对同一块内存同时做上下越界检查。</p></blockquote><p>　　按照我对<a href="https://github.com/CheggEng/electric-fence/tree/master" title="Electric-Fence Githubs" target="_blank" rel="noopener">eFence</a>这版code的理解和阅读过程中产生的疑问，我做了部分修改，具体参考<a href="https://github.com/Donald-Zhuang/Optimized-Electric-Fence/commit/915636f8b2ceb2c53311e6ea93606a65a8f42fd2?diff=split" title="my change" target="_blank" rel="noopener">commit</a>，还有待验证。而我也有想法尝试优化这个实现，一方面是锻炼自己，一方面也是做一个新的挑战，虽然efence跟ASAN确实还是天壤之别的。这次也是因为看到一个团队对tcmalloc进行客制化，实现很好的内存管控，也就有想法多了解些开源方案，当后续遇到类似问题可进行定制，进而提高工作效率。具体就是知乎上这个例子了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们团队的同事搞出了一套终极解决方案用于解决各种内存相关问题（例如内存泄漏，内存被踩坏等），很好用。简单来说就一句话修改tcmalloc，加入audit信息。具体修改包括如下2个方面：</span><br><span class="line">1.在每次分配的时候，多申请12个字节，用于记录分配者的线程ID,栈ID,本次操作是分配还是释放的标志位，分配时间等信息。</span><br><span class="line">2.在tcmalloc 上外挂了一个ringbuffer, 每次内存分配的时候记录下地址信息，线程ID,栈ID,长度，申请还是释放标志位</span><br><span class="line">额外占用的内存其实很小。</span><br><span class="line">对于题主说的内存被踩坏的情况，按照我们的经验，大多数都是野指针导致的，遇到后分析core文件，在ringbuffer中查找这个地址的前几代分配释放记录就一目了然了。</span><br><span class="line">——[如何排查大型C程序中的内存写越界导致的coredump？](https://www.zhihu.com/question/51735480/answer/127297709)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　内存越界类问题都不太好搞，但也充满乐趣，有如侦探抽丝剥茧般。因为处理过好些这类问题，也就有想法将这些手段总汇起来，建立成一个辑录供参考。实际第一篇早已做出，即&lt;a href=&quot;https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/&quot;&gt;GCC SSP Canary功能简介&lt;/a&gt;一篇，这也就是第二篇了。从electric-fence开始主要因其代码简单，一来方便阅读，二来方便自己修改优化。小工具用好即为神器，会用然后再做修改，便能顺心随意。本文最后的总结也提及一个修改tcmalloc实现自己需求的团队例子，器终归是器，用的人才是决定其价值的关键。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="gdb" scheme="https://donald-zhuang.github.io/tags/gdb/"/>
    
      <category term="mprotect" scheme="https://donald-zhuang.github.io/tags/mprotect/"/>
    
      <category term="efence" scheme="https://donald-zhuang.github.io/tags/efence/"/>
    
      <category term="内存越界访问" scheme="https://donald-zhuang.github.io/tags/%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>多进程访问共享库全局变量问题简单实例——全局变量被踩debug方法辑录</title>
    <link href="https://donald-zhuang.github.io/2018/11/15/GlobalVariableInSoForMultihread/"/>
    <id>https://donald-zhuang.github.io/2018/11/15/GlobalVariableInSoForMultihread/</id>
    <published>2018-11-16T02:10:04.000Z</published>
    <updated>2018-11-16T15:25:08.667Z</updated>
    
    <content type="html"><![CDATA[<p>　　上周处理一个问题，发现一个so的结构体全局变量数据异常。一开始怀疑是没dump成功，后面加log发现异常时对象全为0了。确认打印发现该结构体某成员一会为0一会为1，便初步定性为全局变量被踩，最终经过各种手段、alpha和kent大的助攻定位到原因。实际该问题是一个多进程环境共享对象内全局变量分配问题。很好玩的一个问题，就此简要分享。<br><a id="more"></a></p><hr><p>　　<em>“错误包含丰富的信息”　—— Nassim Nicholas Taleb《Antifragile》</em><br>　　前置说明：如下log均是构造出来的，仅作模拟的例子，所以全部log的时间是一样的。这次由于一开始错误的思维定势以及debug过程被各种打断，导致没记录好debug结论，实际debug过程比这篇文章描述的复杂且乱。也正因如此，有了梳理下这个问题处理过程的想法，借以总结下全局变量数据异常时候的处理方法，便于以后参考借鉴。</p><h3 id="1-确定是否有异常读写行为"><a href="#1-确定是否有异常读写行为" class="headerlink" title="1. 确定是否有异常读写行为"></a>1. 确定是否有异常读写行为</h3><p>　　debug就是从最基础的开始，收集各种信息，然后做推断，再找证据证明推断，循序渐进，抽丝剥茧，最终找到问题的根源。对问题的起始定义很重要，比如这次这个问题，首先加log，获取得如下信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 所有用到该结构体的函数入口皆加入如下打印：</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d &gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__ ,stConfig.bUsing, &amp;stConfig);</span><br><span class="line"><span class="number">2.</span> 异常<span class="built_in">log</span>如下：</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _SetXXXParams<span class="number">-644</span>          &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br></pre></td></tr></table></figure></p><p>　　从如上log可以看出，所有用到这个变量的函数都在同个进程同个线程内（PID-2048），这也就可以排除多线程并发引发的全局变量数据篡改问题(我在这里有怀疑过是动态库全局变量问题，但因为进程号相同，直接推翻)。接下来怀疑是在这些函数中有地方去操作这个变量，于是Read the Fucking  Source Code，却发现整个程序中只有XXX_DumpPanelInfo这个函数会去操作这个对象，大致代码如下，可见函数执行后stConfig便不会为0，而注释掉memset，问题依旧。下一个需要确认的就是是否有对这个全局变量的指针引用，指针操作也可以写坏数据，但review了一轮source code，发现并没有，同时也没有发现同名全局变量的存在，也就排除so链接过程出现同名全局变量覆盖问题(有两种，一种是两个so都有同名全局变量，比如<a href="https://www.linuxidc.com/Linux/2011-03/33352.htm" title="Linux系统下DSO同名全局变量浅析" target="_blank" rel="noopener">Linux系统下DSO同名全局变量浅析</a>，一种是bin和so都有全局变量，比如<a href="https://blog.csdn.net/lcalqf/article/details/78129697" title="linux so 动态库中全局变量 被覆盖问题" target="_blank" rel="noopener">linux so 动态库中全局变量 被覆盖问题</a>。)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XXX_DumpPanelInfo</span><span class="params">(&amp;stConfig)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">memset</span>(&amp;stConfig, <span class="number">0</span>, <span class="keyword">sizeof</span>(stConfig))；</span><br><span class="line">    stConfig.bUsing = TRUE;</span><br><span class="line">    ... <span class="comment">// 对stConfig其他成员的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-上GDB确认问题"><a href="#2-上GDB确认问题" class="headerlink" title="2. 上GDB确认问题"></a>2. 上GDB确认问题</h3><p>　　经过这上一轮debug，我们排除了一些常见的可能，也就以此初步推断可能是其他全局变量越界踩内存的问题。在说明我所用的gdb debug方式之前，我们先讲下gdb的watch功能，详细可以参看gdb online document<a href="https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html" title="Setting Watchpoints" target="_blank" rel="noopener">Setting Watchpoints</a>。一般而言，如果不方便review code却又想尽快抓到修改变量的地方，我们可以通过gdb watch功能来实现。但他也有局限性，具体实例如下。我们可以看出，watch适用于同进程内直接对变量访问时的监控，对于越界访问检测没有太大的助力。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">int</span> gVar[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">3</span>       <span class="keyword">int</span> gVar2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6       </span>&#123;</span><br><span class="line"><span class="number">7</span>           <span class="built_in">printf</span>(<span class="string">"gVar&gt;&gt;%p, gVar2&gt;&gt;%p\r\n"</span>, gVar,&amp;gVar2 );</span><br><span class="line"><span class="number">8</span>           gVar[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br><span class="line"><span class="number">10</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line">(gdb) watch gVar2</span><br><span class="line">Hardware watchpoint <span class="number">1</span>: gVar2</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/donald-zhuang/Desktop/demo/a.out </span><br><span class="line">gVar&gt;&gt;<span class="number">0x601040</span>, gVar2&gt;&gt;<span class="number">0x601048</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint <span class="number">1</span>: gVar2</span><br><span class="line"></span><br><span class="line">Old value = <span class="number">0</span></span><br><span class="line">New value = <span class="number">2</span></span><br><span class="line">main () at SimpleSection.c:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br></pre></td></tr></table></figure></p><p>　　不过gdb的x功能（具体参考<a href="http://visualgdb.com/gdbreference/commands/x" title="x Command" target="_blank" rel="noopener">x command</a>）能弥补如上缺陷。当watch抓到变量异常时，我们可以通过x命令第一时间查看进程内存布局。如下这段gdb续上一过程，首先通过print获取gVar2的地址，然后我们在其地址减1的地址上dump数据找到他的上家，继而定位到是谁越界了。这个例子中，我们可以看到就是gVar了。找到调用这个数组的地方，review code即可发现问题所在。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Old value = <span class="number">0</span></span><br><span class="line">New value = <span class="number">2</span></span><br><span class="line">main () at SimpleSection.c:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br><span class="line">(gdb) p &amp;gVar2</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;gVar2&gt;</span><br><span class="line">(gdb) x/<span class="number">4</span>x <span class="number">0x601048</span><span class="number">-1</span></span><br><span class="line"><span class="number">0x601047</span> &lt;gVar+<span class="number">7</span>&gt;:      <span class="number">0x00000200</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure></p><p>　　因为其他原因，我的做法是在抓到异常数据的地方，也就是在SetXXX_Fmodulation-1953入口处加了一个abort，让它coredump，然后通过coredump解析当前内存布局和进程情况。解析coredump可以看到如下信息，其中被踩的对象就是config那一块，其前面的对象是两个锁，还有m_vTag这个对象，通过print m_vTag这个对象，可以看到其成员数据合法、非零，故此不存在前面数据大范围越界踩到stConfig的问题。那就迷糊了，难不成是其他地方的虚地址错误然后神奇得踩到这个位置。<br><img src="/2018/11/15/GlobalVariableInSoForMultihread/memory_alloc.png" title="Memory Info"></p><h3 id="3-mprotect与kernel-hardware-breakpoint"><a href="#3-mprotect与kernel-hardware-breakpoint" class="headerlink" title="3. mprotect与kernel hardware breakpoint"></a>3. mprotect与kernel hardware breakpoint</h3><p>　　对于这种无厘头的问题，就要上利器了，mprotect与kernel hardware breakpoint，前者是跨进程的，后者是进程内有效。因为我们的code中有支持kernel hardware breakpoint，所以我就直接上了，这部分有兴趣大家可以参考这篇博文<a href="https://blog.csdn.net/phenix_lord/article/details/41415559" target="_blank" rel="noopener">内核模块踩内存问题定位利器- hardware breakpoint</a>，参考的实例代码如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sample_hbp_handler</span><span class="params">(struct perf_event *bp,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct perf_sample_data *data,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">"%s value is changed\n"</span>, ksym_name);</span><br><span class="line">dump_stack();</span><br><span class="line">printk(KERN_INFO <span class="string">"Dump stack from sample_hbp_handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hw_break_module_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    </span><br><span class="line">hw_breakpoint_init(&amp;attr);</span><br><span class="line">attr.bp_addr = kallsyms_lookup_name(ksym_name);<span class="comment">//待监视的地址，指令和数据地址均可以</span></span><br><span class="line">attr.bp_len = HW_BREAKPOINT_LEN_4;</span><br><span class="line">attr.bp_type = HW_BREAKPOINT_W | HW_BREAKPOINT_R;<span class="comment">//待监视的访问类型</span></span><br><span class="line">       <span class="comment">//sample_hbp_handler为待监视的地址被访问时调用</span></span><br><span class="line">sample_hbp = register_wide_hw_breakpoint(&amp;attr, sample_hbp_handler, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR((<span class="keyword">void</span> __force *)sample_hbp)) &#123;</span><br><span class="line">ret = PTR_ERR((<span class="keyword">void</span> __force *)sample_hbp);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">printk(KERN_INFO <span class="string">"HW Breakpoint for %s write installed\n"</span>, ksym_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">fail:</span><br><span class="line">printk(KERN_INFO <span class="string">"Breakpoint registration failed\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hw_break_module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unregister_wide_hw_breakpoint(sample_hbp);</span><br><span class="line">printk(KERN_INFO <span class="string">"HW Breakpoint for %s write uninstalled\n"</span>, ksym_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　不过不幸的是，功能并没有支持好，导致没能顺利抓到异常访问行为，就此作罢。既然被踩，那还可以上一招，mprotect，这个函数是通过设置进程内页属性，来实现对内存的读写保护，因为是设置页的属性，这也就决定了该函数能保护的内存需要4K对齐且大小也需要为4K倍数。具体可参考<a href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual</a>。我们的全局变量没有4K大，也就需要构造下，然后验证下问题是否还能复现，具体的操作是根据实际情况对结构体定义调整，类似如下方式塞入dummy数据，然后复现问题，加完之后发现问题依旧复现得到（我在这里怀疑人生了…后加打印发现编译器优化了结构体布局，stConfig.bUsing仍然在首部）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STCONFIG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dummy[<span class="number">4095</span>];</span><br><span class="line">    BOOL bUsing;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span> dummy2[<span class="number">4095</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　既然复现得到，就可以加mprotect保护。我们必须在dump数据后对该区域进行保护，其中第三行是保证地址是4K对齐的，PROT_READ表示将该页设置为只读的。这个函数执行完后，进程内其他地方如果尝试写或执行便会引发页错误，导致coredump，这样我们也就抓到异常点了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XXX_DumpPanelInfo(&amp;stConfig);   <span class="comment">// ensure the data have been initialized</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ALIGN_SIZE (4096)  <span class="comment">// the size of page</span></span></span><br><span class="line"><span class="keyword">char</span> *pstConfig = (<span class="keyword">char</span>*)(((<span class="keyword">int</span>)(&amp;stConfig) + PAGE_ALIGN_SIZE - <span class="number">1</span>) &amp; (~(PAGE_ALIGN_SIZE<span class="number">-1</span>))); <span class="comment">// align to page size</span></span><br><span class="line"><span class="keyword">if</span>(mprotect((<span class="keyword">void</span>*)pstConfig, PAGE_ALIGN_SIZE, PROT_READ))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"protect failed!\r\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">保护执行的打印</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d &gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__, stConfig.bUsing, &amp;(stConfig.bUsing));</span><br></pre></td></tr></table></figure></p><p>　　调整后得到如下log，我们可以看到加粗的两行log，软件不仅进了两次保护，还写了两次！然后没有任何coredump。于是我在加保护之后，尝试补一个写操作，结果如期出现coredump，也就证明保护实际是起效。在这情况下，我老板提醒了我mprotect是同进程内有效，跨进程无效，故以此为根基进入下一个debug。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   &gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span>__</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _SetXXXParams<span class="number">-644</span>        &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   &gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span> __</span><br></pre></td></tr></table></figure></p><h3 id="4-印PID，共享库全局变量问题"><a href="#4-印PID，共享库全局变量问题" class="headerlink" title="4. 印PID，共享库全局变量问题"></a>4. 印PID，共享库全局变量问题</h3><p>　　基于各种对变量被踩debug的不合理现象，问题的本质实际在不断展露。不过我还没能抓到点，找老板指点，在如上基础上，我老板让我在log上印pid，结果如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d PID(%d)&gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__, getpid(),stConfig.bUsing, &amp;stConfig);</span><br><span class="line"></span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   (PID<span class="number">-2065</span>)&gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span>__</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _SetXXXParams<span class="number">-644</span>        (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_En<span class="number">-1928</span>             (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_En<span class="number">-1928</span>             (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   (PID<span class="number">-2066</span>)&gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span> __</span><br></pre></td></tr></table></figure></p><p>　　打印相关进程的PID信息如下，根据进程文件可知，如下多个进程都是同一个bin档实现的服务，然后经过2052的logwrapper将log打印出来，因此log上的PID都是logwrapper的，至此问题原因昭然若揭，上面debug的各种不合理之处也就有了明确的解释了。如上所看为何变量地址一样，为何mprotect“起效和失效”，在这里可以看到，原来这是一个典型的动态库内全局变量问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console:/<span class="meta"># busybox ps | grep Process</span></span><br><span class="line"><span class="number">1984</span> <span class="number">0</span>        <span class="number">0</span>:<span class="number">00</span> /application/bin/Process</span><br><span class="line"><span class="number">2052</span> <span class="number">0</span>        <span class="number">0</span>:<span class="number">00</span> &#123;logwrapper&#125;/application/bin/Process</span><br><span class="line"><span class="number">2065</span> <span class="number">0</span>        <span class="number">0</span>:<span class="number">43</span> /application/bin/Process</span><br><span class="line"><span class="number">2066</span> <span class="number">0</span>        <span class="number">6</span>:<span class="number">52</span> &#123;ServiceAProcess&#125;/application/bin/Process</span><br><span class="line"><span class="number">2067</span> <span class="number">0</span>        <span class="number">0</span>:<span class="number">00</span> &#123;ServiceBProcess&#125;/application/bin/Process</span><br></pre></td></tr></table></figure></p><p>　　关于这个问题，本质是共享对象中的全局变量会在可执行档中有一个副本，并且实际运行中采用的便是这个副本，不同进程对同一个共享对象的全局变量引用是各自独立的。前阵子看了程序员自我修养的196页中，有如下解释</p><blockquote><p>由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来，为了能使得链接过程正常进行，链接器会在创建可执行文件时，在它的.bss段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的bss段中还有一个副本，如果同一变量同时存在于多个位置中，这在程序的实际运行过程中肯定是不可行的。<br>于是解决办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。elf共享库编译时，默认都把定义在模块内部的全局变量当做定义在其他模块的全局变量。…</p></blockquote><h3 id="5-终章，我要去赶飞机了"><a href="#5-终章，我要去赶飞机了" class="headerlink" title="5. 终章，我要去赶飞机了"></a>5. 终章，我要去赶飞机了</h3><p>　　至此问题也就解决了，根本原因也就是两个不同的进程对同一个共享库的全局变量进行引用，而我们的多个服务进程是基于同一个bin通过不同参数启动，coder没有注意到两个module不在同个service进程中，导致采用的全局变量没能正确初始化，继而导致异常的发生。当然实际问题比这个更复杂，debug理清过程也花了我两天的时间，不过这次也是有收获的，哈哈，读书有用啊。我要赶飞机了，梳理就暂时到此，下次再调整下文章和引用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　上周处理一个问题，发现一个so的结构体全局变量数据异常。一开始怀疑是没dump成功，后面加log发现异常时对象全为0了。确认打印发现该结构体某成员一会为0一会为1，便初步定性为全局变量被踩，最终经过各种手段、alpha和kent大的助攻定位到原因。实际该问题是一个多进程环境共享对象内全局变量分配问题。很好玩的一个问题，就此简要分享。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="gdb" scheme="https://donald-zhuang.github.io/tags/gdb/"/>
    
      <category term="mprotect" scheme="https://donald-zhuang.github.io/tags/mprotect/"/>
    
      <category term="hardware breakpoint" scheme="https://donald-zhuang.github.io/tags/hardware-breakpoint/"/>
    
  </entry>
  
  <entry>
    <title>《见识》观后</title>
    <link href="https://donald-zhuang.github.io/2018/08/11/enlarge-Vision/"/>
    <id>https://donald-zhuang.github.io/2018/08/11/enlarge-Vision/</id>
    <published>2018-08-11T13:34:10.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　前阵子公司活动，我参与投稿为部门赢得一小笔活动经费，部长让我选一份100元内的礼物作为奖品鼓励，最终我选了吴军老师的两本书《智能时代》和《见识》。就在上个月，我看完了《见识》，鉴于以往看书都是找寻书中最有益于自己的一点加以实践，化为己用，其他观点仅作参考，对于好书则会闲时再翻阅。近来却也发现，这种方法读下来，很多书读完就忘，理解流于表面，没能真正看懂一本书。也因此，我决定换个方式读书，即在看完之后，将自己的体会写出来，再慢慢咀嚼消化，真正去感受这本书，不再走马观花，希望这样能有更好的效果。见识这本书，也将是我这么实践的第一本。<br><a id="more"></a></p><hr><p>　　见识，我豆瓣给分4星，有名气的加分因素。在此之前，《浪潮之巅》和《数学之美》让我吴军老师科普方式很是喜欢，也就对这本抱有一定的期待。此次看完确有所获，自觉书中有些内容值得分享，但书中也有部分内容用吴老师的话说，“尽是些绝对正确，但又毫无用处的大道理。”因此是一本中等质量的书。对这本书的简单总结，我觉得豆瓣网友 <a href="https://www.douban.com/people/suochristine/" target="_blank" rel="noopener">violet&amp;blue</a>做得很好，具体如下。其中几点我亲身实践过，受益匪浅，也贴出来与君共享。</p><blockquote><p>1、最有效的沟通是第一时间直接给出答案，然后补充解释（金字塔原理）；<br>2、做事要积极，做公司的主人，而非过客；<br>3、用OKR的方式去管理工作和生活；<br>4、凡事做记录；<br>5、少做事，把事情做好（排优先级）；<br>6、钱的本质是对各种资源的所有权和使用权的量化度量；<br>7、讲话的人有责任保证信息按时、准确地送达对方，并确认对方收到；<br>8、每件事都要产生应该的的效果，不做无用功；<br>9、有风险意识，多思考</p></blockquote><p>　　序言部分，吴军讲起他对命运的理解，“所谓命就是一个人看问题和做事情的方法”，它“主要取决于两个因素，环境的因素和我们自己对未来走向划定的方向”，要命好，就需要信命和认命，“信命是知道自己有所不能，认命则是不超越命运给自己画的线，对于得不到的坦然接受”。这观点偏中性，我上周写的<a href="https://donald-zhuang.github.io/2018/08/04/my-rules/">行事三原则</a>，观点与此类似。简而言之，凡事就是要先尽人事，随后才听天命，而最高智慧是能够明了所能和所不能，对所能之事精进，对不能之事坦然接受。</p><p>　　开文提“成功只是手段，不是目的”，提醒我们一定要明白自己真正想要的是什么，不能为了成功而追求成功，这也是本书的最基本立足点。书中言，“成败与否取决于见识的高低，而不是自己简单的努力”，这也就是很多人追求更高见识的原因。但，众所周知，见识并不是看一本书，听几番道理就能够增长开阔的，更多来自于阅历和实践，其过程类似于论语中孔子“十有五而志于学，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而从心所欲不逾矩。”也有如王国维说的治学三境界，每达到一个境界，自然会看到局限，然后精进到下一个境界，一环扣一环。就此而言，这本书讲的是如何通过一些观念常识、一些正确的判断和决策方法、一些行动，提升自己的见识，实现精进。</p><p>　　这本书的定位也就决定书中观点会多，而篇幅所限也就只能浅尝，无法深入。如公司新旧更替，这一点在浪潮中有所介绍，因此本书在讲述之时，也并未多做深入，但其中几个点串联起来，其思路也不错。吴老师说，小公司得以超越大公司在于其理念更新，大小之争是新旧时代的竞争，旧时代一定竞争不过新时代。在后面却也说，谷歌“为了避免重复IBM和微软失败的老路，佩奇才把已经成熟的果实交给他人看管，自己负责起最需要支持、最需要资源的新业务。”这阐述了一个现实，新旧时代的竞争，有时需要环境和各种资源的支持，不然在阶层和资源分配固话的大企业中，新的创意即便很好，也很容易胎死腹中。应对这种资源重分配问题的，除了像佩奇这种亲自下海，国内还有一个不错的理念，芬尼克兹老总宗毅的<a href="https://www.douban.com/note/616755708/" target="_blank" rel="noopener">裂变创业理念</a>， 通过员工参股公司老员工内部裂变创业，一方面能很好选拔人才，留住人才，鼓励员工创新，另一方面也能进一步扩展公司的业务，其间的新人组也能很好看到新生代的理念和需求，感知潜在的可能，是一种成熟而又安全的企业发展机制，我也曾有幸参与一次现场活动，方式新颖也很安全。</p><p>　　关于好产品的定义，吴老师认为首先是要功能好，其实要让大家认可相应的品牌。这点好理解，首先假设价格皆可接受，质量不好的产品在市场上经过一段时间自然会被质量好的淘汰；相同质量的两种产品，人们则会接受品牌名气高一点的。常识里，好品牌除了有质量上的保证，遇差的风险低，免去选择的苦恼，更重要还有一点摩拜单车王晓峰说得很好，“一个客户买一个产品与否，功能、性价比、好友等都是次要的，最重要的是有面子。”<a href="http://www.sohu.com/a/123231990_592170" target="_blank" rel="noopener">1</a>不少品牌的价值就在于他满足了很多人的面子，用户就愿意买单了，比如海底捞、苹果手机等。</p><p>　　回到IT产品，吴老师认为IT产品被市场认可需要经历三个阶段，第一阶段，有好想法但产品问题多，只有技术敏感的人才会去关注和使用；第二阶段是解决第一阶段的可靠性和稳定性问题，但成本高掩盖了技术上的优势，影响其推广；第三阶段，解决价格问题，普及大众。这也就是“第三眼美女”的概念，任何过不了第三眼的产品都不算好的产品。不过私以为，这三个过程还需伴随着市场的成熟，有一些优秀的产品因为市场的不成熟，其理念过于超前，不能为市场所接受，最终不能得到成功的推广，这样的例子比比皆是(<a href="http://news.mydrivers.com/1/192/192836.htm" target="_blank" rel="noopener">十大因理念超前而惨败的公司</a>)。</p><p>　　除了上面提及王晓峰的一个观点，书中也提及了王晓峰的另外两个销售智慧，“销售的本质是把钱收回来，把钱收回来的地位高于把东西卖出去；持续的生意——让顾客把买的东西用光”，前一点讲的就是卖出去只是手段，而收回来才是目的。我们公司在这部分采用一种代理机制避开风险，芯片通过代理商卖给客户，代理商跟我们拿芯片是现付(不完全现付)，而代理商那边给到客户则是可延期付账，因此前阵子乐视的拖账风波并未真正影响我司。</p><p>　　对于第二点，吴老师拓展到团队管理，“管理一个团队时，你给员工的奖励不能仅仅是一次充值的促销，然后让他们享受很多年，而是想办法让他们消耗掉这种物质和精神上的奖励，能够继续轻装奋斗。”我司的奖励体系便是如此，工资够养活自己，而每年的奖金却是最浓墨重彩的一笔，而每次奖励评估的是过去半年你的表现和做过什么，每次评价完之后一切归零，从头开始。这个机制支撑了多少人的拼搏向前，犹如悬线萝卜一根。</p><p>　　回到最近，网上疯传谷歌即将回归中国，这也引发了谷歌百度之争的讨论。其中，网友们支持谷歌的论据可以用本书的一个说法总结，就是谷歌“将有用的信息送达每一个用户”。我也相信如果百度不做改变，谷歌回归后必将取得胜利，当然胜负之分未必就是在搜索引擎上。另外，谷歌的这个产品理念核心，Airbnb、Uber、滴滴也是如此践行，他们将有用的资源整合送达每个用户，而这些资源不是他们自己的，但取得了成功，因为他们都成功借此将产品做成了平台。</p><p>　　如上的讨论归结起来，讨论的便是商业的本质，一言概之，商业就是解决人们遇到的问题，并让用户愿意多花钱。</p><p>　　讲完这些大的，回归到小的，讲个人。在讲巴菲特的人生智慧时，书中谈到技术和艺术的区别，“技术可以通过学习不断进步，而且它有可传承性和可叠加性，也就是说徒弟不仅能学到师傅全部的技术，而且还可能做得更好。但是艺术没有这种特性。”这段指明了两个点，一个是师承关系的重要性，另一个则是点明哪些成功是可以复制的，哪些则是无法复制的。这也很好地让你明白，有何能有何不能，清楚自身优势形成强的着力点。</p><p>　　然后提出伪工作的概念，什么是伪工作？这个概念有一定的价值，因为对照这几条，反观自身，我们能避免很多把时间浪费在那些可做可不做的事情上，提高自己的效率，也能让自己找到逃离舒适区的方法。</p><blockquote><p>1、那些既不能给公司带来较大收益，又不能给用户带来价值的改进和“升级”，很多都是伪工作。<br>2、有的人，明明能够通过学习一种新技能更有效地工作，却偏偏要守着过去的旧工具工作，甚至手工操作，这种人是典型的为工作者。<br>3、做事情前不认真思考，做事时通过简单的试错方法盲目寻找答案。<br>4、做产品不讲究质量、不认真测试，上线后不停地修补，总是在花费很多的时间和精力找漏洞和打补丁。<br>5、不注重用有限的资源解决95%的问题，而是把大部分时间和精力用于纠结不必要的5%的问题。<br>6、每次开会找来大量不必要的人员旁听，或者总是去俺家那些不必要参加的会议。</p></blockquote><p>　　随后对于开发人员有一个警醒是很有价值，“如果一个开发人员不清楚自己所做的产品盈利能力如何，是非常危险的。”诚如文中所言，如果只执迷于技术，不了解自己开发的产品的盈利能力，那很容易做无用功，研发人员要站在“做什么事情能让公司最大获益”的高度去工作，这样才能真正让自己更能创造价值，更有价值，不至于被淘汰。而文中也提出一个模仿朗道五级形成的“五级工程师”概念，这个给诸位工程师们提供了一个自己定位的参考。</p><blockquote><p>第五级，一个人毕业后，经过一段时间的锻炼，能够熟练应用工程的知识和技能解决问题，独立完成所分配的工作，而不需要他人的指导。<br>第四级，需要有领导能力和在工程上把大问题化解为小问题的能力。<br>第三级，能够独立带领其他人做出一个为公司挣得利润的产品，本身必须是非常好的产品经理。<br>第二级，是能够做出先前没有的东西，世界因为他们多少有点不同。如jeff dean。<br>第一级，是开创一个产业的人，包括爱迪生、福特、贝尔等人。</p></blockquote><p>　　在方法介绍中，有谈及谷歌的OKR理念，这个理念跟我们公司的IDP(<a href="https://www.opm.gov/wiki/training/individual-development-plans.ashx" target="_blank" rel="noopener">Individual Development Plan</a>)很像，但我们过IDP都是比较个人的，个人能力太守图也是保密的，但OKR则将这种进度公开化，其方法也许值得我司参考以进一步改善当前的IDP推展困境。<br><img src="/2018/08/11/enlarge-Vision/OKR.jpg" title="OKR example"></p><p>　　这本书还有好些不错的观点和方法，比如“经营和管理的秘诀：不给选择”的观点、进度跟踪的消耗曲线模型等，不过本文不想罗列清单，因此点到即止。而读书了解到的方法和概念虽能给你现实生活提供一些助益，但也如我开篇提及的孔子，有些方法或者理念大家都懂，但践行不下去，其实这也就是见识和能力的局限。当你没到那个境界，没到那个火候，你所读就只能是一种观点，不能化为肌体的一部分。唯有知识经验进一步增长，见识开阔，你真正能理解时，自然就会用起来。所以看一本书，虽说未必能很快见效，但若有心，有朝一日，种下的种子终会萌芽成长。</p><p>　　这篇文章写下来长度超过我的预期，内容也颇为繁杂，跟书的设定有一定关联吧。最后，我也想用圣艾德蒙的名言收尾，总结本文，Study as if you were to live forever，live as if you were die tomorrom.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　前阵子公司活动，我参与投稿为部门赢得一小笔活动经费，部长让我选一份100元内的礼物作为奖品鼓励，最终我选了吴军老师的两本书《智能时代》和《见识》。就在上个月，我看完了《见识》，鉴于以往看书都是找寻书中最有益于自己的一点加以实践，化为己用，其他观点仅作参考，对于好书则会闲时再翻阅。近来却也发现，这种方法读下来，很多书读完就忘，理解流于表面，没能真正看懂一本书。也因此，我决定换个方式读书，即在看完之后，将自己的体会写出来，再慢慢咀嚼消化，真正去感受这本书，不再走马观花，希望这样能有更好的效果。见识这本书，也将是我这么实践的第一本。&lt;br&gt;
    
    </summary>
    
      <category term="所读" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E8%AF%BB/"/>
    
    
      <category term="书" scheme="https://donald-zhuang.github.io/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>行事三原则</title>
    <link href="https://donald-zhuang.github.io/2018/08/04/my-rules/"/>
    <id>https://donald-zhuang.github.io/2018/08/04/my-rules/</id>
    <published>2018-08-04T10:48:52.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　这阵子发现思考少了，浪多了，实在不该。原本想分享下上周我解不动，最后请AE team大佬帮忙解决的一道难题。原理是两个库的函数名相同且同时加载到内存中，导致执行bin档链接错误的vtable，引发coredump问题，不过昨天还是没能理解这套异常的发生机制和复现方案，所以分享不了，等我看下书，学习下再来。<br>　　今早起来时想起过往一些事，也就想到自己处事的三个基本原则，这三个原则支持我克服了诸多难题，经过各种实践后演化成为自己身体的一部分，也就觉得这个可以聊聊的。<br><a id="more"></a></p><hr><p>　　困难在我们成长道路上如影随行，每一次进步实际也是我们和困难搏斗后收获的成果。所以每当我们吐槽举步维艰之时，常会有朋友安慰道，“天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤…”。这样看来，困难只是一种试炼，让我们看到当下的极限在哪，也让我们得以体验那种无力感。倘若能审时度势，顺势而为，也终能收秦破吴，担起“大任”。</p><p>　　不过，这么多年的生活经历却也教我，有些困难真不是打打鸡血，咬咬牙就能过去的，有些时候还真需要你面对现实或破釜沉舟、或卧薪尝胆，至于结果最终也只能尽人事而听天命。对此，自己也长出一套对策，也就是开头说的三个原则，这三个原则在面临一些重要的问题时，常帮我度过一些难关。一句话总结出来就是，<strong>一切问题皆有解，一切都会过去，复盘成败。</strong></p><p>　　<strong>一切问题皆有解</strong>。实际是我对<strong>Nothing is impossible</strong>的衍生，这句话对我的启发和影响更多在于视野上。现实生活中，很多看似难以理解或者不可解的问题，实际只是我们身在庐山，不识其真面目。就好比魔术，我们觉得不可能的事情，魔术师咫尺之间呈现在你面前，还能让你看不出一丝破绽，而生活中的困难和诸多难题又何不如此。也因此，当陷入困境之时，需要时刻提醒自己，要跳开出来，用第三方的视角审查周围的一切，找出自己不理解、不确定、不可能中的可能，找到那一丝线头，抽丝剥茧寻求答案。</p><p>　　这种视野也让我发现很多让你深陷其中的难题是视野局限出来的，敢于挑战自己信仰的，反而会有更强大的进步。用马克·吐温的话说就是，<strong>“让我们陷入困境的不是无知，而是看似正确的谬误论断。”</strong>(“It ain’t what you don’t know that gets you into trouble. It’s what you know for sure that just ain’t so.”)，挑战并颠覆这样的“谬误论断”，能让你解决很多看似无解的问题。所以，困难之时，一定要坚信任何难题都有解，需要做的是冷静思考。既要看到自己的局限和无力之处，也要看到潜在的可能，不然最后就只能跟项羽一样自刎垓下。</p><p>　　<strong>一切都会过去</strong>，原文为<strong>This too shall pass</strong>。这句来自一个所罗门王的一则<a href="http://kfbck.blog.163.com/blog/static/56013136200893095455577/" target="_blank" rel="noopener">寓言故事</a>。我一直很喜欢这句话，如所罗门王期待效果一样，“它有魔力，快乐的人看见它会变得悲伤；而悲伤的人看见它会变得快乐。”，每当遇到短时无法克服的困难，无法摆脱的困境时，我便会以此安慰自己。回头想想过往那些自认难熬的时刻如何度过，再想想未来回头再看此时的感觉，一些将变得如此平淡。当自己为了一时的成绩过于骄傲时，也会心里默念一遍压压自己。这样看问题也就会用更远的视角来审视此时，一切的一切并没什么大不了的。</p><p>　　最后就是<strong>复盘成败</strong>。<a href="http://wiki.mbalib.com/wiki/%E5%A4%8D%E7%9B%98" target="_blank" rel="noopener">复盘来源于围棋术语</a>，是指下完一盘棋之后，重新在棋盘上把对弈过程走一遍，以期看清自己和对手各自短长，查漏补缺，实现棋艺的精进。我曾看过<a href="https://book.douban.com/subject/25702395/" target="_blank" rel="noopener">《复盘》</a>这本书，据说这个技巧在联想中被推行。我也曾在公司新生分享中，介绍过这个技能。我们常鼓励大家在有条件的时候多试错，而试错只是一个开头，其真正的目的在于随后的复盘和改进，《孟子·告天下》中提及，“人恒过，然后能改”，人只有多犯错或了解别人犯过的错，才能避免重蹈覆辙。</p><p>　　除了复盘败和错，同样当你克服困难、取得胜利时，也值得去复盘，借此了解相关的模式在未来可否复现并助攻自己再次取得胜利，或者反向思考，当别人采用相同的方式决战自己时，有无方法攻克。我相信这一点在大疆的Robot Master大赛中，不少团队践行得很好，因为每年我们都会发现，去年一些优秀的战略或者攻防技术，在今年会被其他队伍学习推广开来，并取得更好的效果。同样，也会有相应措施来应对这样的策略。犹如达尔文的生物进化论，优胜略汰，好的基因不断遗传进化，繁衍更加优秀的生命。</p><p>　　如上三条也就是我常提醒自己的原则或说策略，实际上复盘这条是为了不提出真正的第三条而顶上的。复盘目前我也还在学习和使用。这三条其实归结起来，前两条讲的是应对困境需要有的心态，不惧困难，寻求解决，克服不了时，也莫自甘堕落，应有卧薪尝胆之心，而最后一条则是寻求精进的策略，取一把柳叶刀剖开细看，自查自纠。人在不同阶段都会有不同的思维和决策原则，而这三条就是当下我所践行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这阵子发现思考少了，浪多了，实在不该。原本想分享下上周我解不动，最后请AE team大佬帮忙解决的一道难题。原理是两个库的函数名相同且同时加载到内存中，导致执行bin档链接错误的vtable，引发coredump问题，不过昨天还是没能理解这套异常的发生机制和复现方案，所以分享不了，等我看下书，学习下再来。&lt;br&gt;　　今早起来时想起过往一些事，也就想到自己处事的三个基本原则，这三个原则支持我克服了诸多难题，经过各种实践后演化成为自己身体的一部分，也就觉得这个可以聊聊的。&lt;br&gt;
    
    </summary>
    
      <category term="所思" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>GCC SSP Canary功能简介</title>
    <link href="https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/"/>
    <id>https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/</id>
    <published>2018-07-21T21:32:04.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　处理一个开机coredump问题时，发现是一个必现canary问题，即内存越界访问。一般这类问题发生在数组越界访问，不过这次出现的rootcause有所不同，为代码未对齐导致结构体没对齐，继而在数据传输过程中出现访问越界。bug简单，但鉴于canary是一个有趣的设计，犹如人体免疫系统的表层屏障，能有效规避一些bug，因此我便萌生兴趣系统地了解这个机制，相关学习记录成此文。<br><a id="more"></a><br>　　这篇文章首先会介绍canary的基本原理、使能方式、运行机制、canary值产生原理，最后通过gdb一个实例完整解析整个运行流程，阐释debug过程，后续我也争取更加详细阐述canary一些设计的深入原理和目的。Hope you can enjoy it.</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>　　我遇到的实际问题如下，可以看到<strong>__stack_chk_fail</strong>的字眼，也就是canary问题的标志，这类问题就是栈内存越界访问导致，一般出现在数组越界上，不过这次我们遇到的是代码对齐问题。debug时我看了下code，猜原因，然后对代码就找到rootcause。实际对canary熟悉后，基本可以很快定位问题。此次分析不会提供原始问题代码，毕竟直接晒公司代码是要收律师函的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0xea36bd5c in raise () from /lib/libc.so.6</span><br><span class="line">#1  0xea36f838 in abort () from /lib/libc.so.6</span><br><span class="line">#<span class="number">2</span>  <span class="number">0xea3a32cc</span> in ?? () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0xea4212e0</span> in __fortify_fail () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0xea42129c</span> in __stack_chk_fail () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0xecd173dc</span> <span class="function">in <span class="title">XXX_HAL_AUD_SetGeqEnable</span> <span class="params">(ePort=XXX_MW_SND_OUTPORT_I2S1,</span></span></span><br><span class="line">    bOnOff=XXX_TRUE) at src/xxx_hal_audio.c:976</span><br><span class="line">#<span class="number">6</span>  <span class="number">0xee9d8428</span> in XxxAudioCtrl::GEQAef::setGEQEnable (<span class="keyword">this</span>=<span class="number">0xe6400590</span>,</span><br><span class="line">    bOnoff=bOnoff@entry=XXX_TRUE)</span><br><span class="line">    at ../middleware/sdkctrl/xxx_mw_audioctrl.cpp:<span class="number">2200</span></span><br><span class="line">#<span class="number">7</span>  <span class="number">0xee9d9168</span> <span class="function">in <span class="title">setSndEffect</span> <span class="params">(pctSndModeParam=&lt;optimized out&gt;)</span></span></span><br><span class="line">    at ../middleware/sdkctrl/xxx_mw_audioctrl.cpp:423</span><br><span class="line">#<span class="number">8</span>  <span class="number">0xeeaa5efc</span> <span class="function">in <span class="title">setSndModeSetting</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ptSndModeSetting=ptSndModeSetting@entry=<span class="number">0xe587ecd4</span>)</span></span></span><br><span class="line">    at ../middleware/setting/xxx_mw_audio.cpp:4181</span><br></pre></td></tr></table></figure></p><h3 id="2-GCC-SSP的canary基本原理"><a href="#2-GCC-SSP的canary基本原理" class="headerlink" title="2. GCC SSP的canary基本原理"></a>2. GCC SSP的canary基本原理</h3><p>　　Stack Canary是GCC <a href="https://wiki.osdev.org/Stack_Smashing_Protector" target="_blank" rel="noopener">Smash Stack Protector(SSP)</a>机制的一个组成部分。通过在loader加载程序时给进程预留一个随机数，称为Canary，当进程内各个函数做栈初始化时，GCC SSP在局部变量和EBP之间插入该值，并在函数返回时，取出该值检查是否被改写，以此判定是否发生内存越界访问等相关问题。下面我们将通过一个实例来解析其实现，文章采用的系统环境如下。</p><blockquote><p>Linux version 4.4.0-119-generic (buildd@lcy01-amd64-013)<br>gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)</p></blockquote><p>　　关于测试采用的代码如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filename: Canary_demo_naive.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canaryTest</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    str[<span class="number">0</span>]  = <span class="number">0xAB</span>;</span><br><span class="line">    str[<span class="number">18</span>] = <span class="number">0xBC</span>;</span><br><span class="line">    str[<span class="number">19</span>] = <span class="number">0xEF</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    canaryTest();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-1-功能使能方式"><a href="#2-1-功能使能方式" class="headerlink" title="2.1 功能使能方式"></a>2.1 功能使能方式</h4><p>　　canary功能分两个阶段实现，</p><blockquote><ol><li>编译阶段通过相关编译开关使能SSP，在满足条件的函数中嵌入代码</li><li>在运行阶段检测实现，运行到相关代码检测是否发生栈越界访问，是则终止程序执行(abort)</li></ol></blockquote><p>　　编译阶段，通过如下编译开关控制需要在哪些函数上加保护，目前常用的开关有如下几种，相关详细介绍可以参考<a href="https://lwn.net/Articles/584225/" target="_blank" rel="noopener">“Strong” stack protection for GCC</a>, 实际还有另外两种功能，不过比较少用，不做介绍。</p><blockquote><ol><li>-fstack-protector (GCC 4.1): 当函数定义大小大于等于8字节的数组时使能Canary，当然也可以通过–param=ssp-buffer-size=N 来控制对应的起效阈值</li><li>-fstack-protector-all: 对所有非内联函数使能Canary</li><li>-fstack-protector-strong (GCC 4.9): 满足以下三个条件都会插入保护代码，相对前两种具有更好的表现，其相关历史可参考<a href="https://outflux.net/blog/archives/2014/01/27/fstack-protector-strong/" target="_blank" rel="noopener">Kees Cook blog</a><br>1) 局部变量的地址作为赋值语句的右值或函数参数；<br>2) 局部变量为数组或含数组的数据类型，忽略数组的长度和类型；<br>3) 带register声明的局部变量</li><li>-fno-stack-protector: 禁用canary功能</li></ol></blockquote><p>　　对上文的Canary_demo_naive.c采用gcc -S Canary_demo_naive.s Canary_demo_naive.c和gcc -S Canary_demo_naive-no.s Canary_demo_naive.c -fno-stack-protector，比较编译出来的差异如下。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/DiffBetweenCanaryOnOff.png" title="The difference about Canary function"><br>　　依据上图左侧汇编代码，我们可以画出如下内存分布图。初始化阶段，从FS[40]抓取一个64bit的random值(canary)保存在栈底，返回时取出该值与FS[40]比较，若该值发生变化，调用__stack_chk_fail报错退出程序。显而易见，当出现越界访问时，canary值会被改写，检测机制生效，这也就是SSP Canary的运行阶段的实现原理。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/stack.png" title="The Stack"></p><h4 id="2-2-功能缺陷"><a href="#2-2-功能缺陷" class="headerlink" title="2.2 功能缺陷"></a>2.2 功能缺陷</h4><p>　　再看回上文汇编部分。我们申请的是一个20 bytes数组，考虑canary的8 bytes，则分配时应该是28 bytes，但编译器申请的是32字节，经过几次测试我发现，编译器分配的长度是满足申请所需的最小16n bytes。<br>　　这个实现会出现什么问题呢？如果我们所需的字节数加上8刚好等于16n时，一越界，canary就会被才到，功能正常。但如果所需长度小于16n，就会出现gap，当越界访问不超越这个gap，就会出现检测不到越界的问题。Canary_demo_naive.c中越界访问str[23]是检测不到的，只有在写str[24]真正踩到canary时才会报错。</p><h4 id="2-3-canary的产生"><a href="#2-3-canary的产生" class="headerlink" title="2.3 canary的产生"></a>2.3 canary的产生</h4><h5 id="2-3-1-Canary常见类型"><a href="#2-3-1-Canary常见类型" class="headerlink" title="2.3.1 Canary常见类型"></a>2.3.1 Canary常见类型</h5><p>　　Canary的类型主要有三种，Terminator canaries、Random canaries、Random XOR canaries。后面我们可以看到GCC源码中Terminator和Random XOR有相应实现，三者区别如下。<br>　　<strong>Terminator canaries</strong>：缓冲区溢出攻击中大部分是通过字符串操作实现，基于此，Terminator Canary通过NULL、CR、LF或-1的组合形成。攻击者若想绕过Canary检查，则必须在其攻击字串中加入NULL，而strcpy类函数都是以NULL为字符串结束符，这样就成功规避了此类针对标准库函数的漏洞利用。<br>　　<strong>Random canaries</strong>：Terminator的缺点在于值固定且可知，攻击者可通过其他方式（memcpy）绕过，因此Random Canary应运而生。一般来说，Random Canary产生于一个熵值足够大的随机数发生源，在程序初始化阶段保存在一个不可读的位置，并留存在一个全局变量中，而后者也就意味着攻击者依旧有机会获取到这个值，但实际已经能隔绝大部分攻击。<br>　　<strong>Random XOR canaries</strong>：在随机数的基础上，将之与部分控制符通过XOR操作形成，这样攻击难度进一步提升，攻击者需要获取到随机数、控制符和对应算法才能获取到对应的Canary值来实现绕过。<br>　　实际上，GCC中采用了Random配合Terminator的方式实现Canary值的生成和使用。</p><h5 id="2-3-2-GCC-Canary生成原理"><a href="#2-3-2-GCC-Canary生成原理" class="headerlink" title="2.3.2 GCC Canary生成原理"></a>2.3.2 GCC Canary生成原理</h5><p>　　在了解了其工作原理和类型，接下来介绍GCC中Canary这个值的来源。我们前面提到是通过FS[40]获取到的，那FS[40]这个值又是从何而来？<br>　　因为这个值在main函数中就会被用到，因此其产生早于main函数。我们也知道，main()并不是进程运行的第一个函数，其在linux中的启动过程为 <strong>_start -&gt; <strong>libc_start_main -&gt; </strong>libc_csu_init -&gt; _init -&gt; main -&gt; _fini</strong>，更具体可以通过文章<a href="https://blog.csdn.net/gary_ygl/article/details/8506007" target="_blank" rel="noopener">linux编程之main()函数启动过程</a>了解。而<strong>__libc_start_main</strong>之后的流程实现于glibc。有这个基础后，我们可以通过glibc-2.27的源码，了解Canary值的来源。<br>　　首先我们来了解下FS这个寄存器存放的基址是什么东西，通过flow <strong><strong>libc_start_main &gt;&gt; </strong>libc_setup_tls &gt;&gt; TLS_INIT_TP</strong>，看到TLS_INIT_TP这个宏的实现如下，如下位置将%fs的基址设置为TLS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since 'errno' is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure 'errno' must not be touched.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We have to make the syscall for both uses of the macro since the</span></span><br><span class="line"><span class="comment">   address might be (and probably is) different.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;      \</span><br><span class="line">     <span class="keyword">int</span> _result;      \</span><br><span class="line">      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>      \</span><br><span class="line">     _head-&gt;self = _thrdescr;      \</span><br><span class="line">      \</span><br><span class="line">     <span class="comment">/* It is a simple syscall to set the %fs value for the thread.  */</span>      \</span><br><span class="line">     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">"syscall"</span>      \</span><br><span class="line">   : <span class="string">"=a"</span> (_result)      \</span><br><span class="line">   : <span class="string">"0"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) __NR_arch_prctl),      \</span><br><span class="line">     <span class="string">"D"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) ARCH_SET_FS),      \</span><br><span class="line">     <span class="string">"S"</span> (_thrdescr)      \</span><br><span class="line">   : <span class="string">"memory"</span>, <span class="string">"cc"</span>, <span class="string">"r11"</span>, <span class="string">"cx"</span>);      \</span><br><span class="line">      \</span><br><span class="line">    _result ? <span class="string">"cannot set %fs base address for thread-local storage"</span> : <span class="number">0</span>;     \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>　　通过上面宏我们可以看到该基址指向的数据类型为tcbhead_t，对应数据结构如下,因为我的系统是x86_64，因此计算对应的偏移可得FS[40]对应的成员是stack_guard。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  ........</span><br><span class="line">  <span class="keyword">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></p><p>　　而stack_guard是通过如下代码设置。其中，_dl_random为_dl_sysdep_start函数从内核获取到的一个随机数，经_dl_setup_stack_chk_guard计算生成canary，再通过THREAD_SET_STACK_GUARD宏则将canary赋值%fs:0x28。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Set up the stack checker's canary.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>　　_dl_setup_stack_chk_guard实现如下，可以看到有两种实现方式，当_dl_random为空时，Canary取值为0xff10，否则将_dl_random低8 bits置0算得canary，这样能保证最后一个字节是’\0’，也就是终止符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> __attribute__ ((always_inline))</span><br><span class="line">_dl_setup_stack_chk_guard (<span class="keyword">void</span> *dl_random)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> num;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[<span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>)];</span><br><span class="line">  &#125; ret = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dl_random == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ret.bytes[<span class="keyword">sizeof</span> (ret) - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">      ret.bytes[<span class="keyword">sizeof</span> (ret) - <span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (ret.bytes, dl_random, <span class="keyword">sizeof</span> (ret));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></span><br><span class="line">      ret.num &amp;= ~(<span class="keyword">uintptr_t</span>) <span class="number">0xff</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> BYTE_ORDER == BIG_ENDIAN</span></span><br><span class="line">      ret.num &amp;= ~((<span class="keyword">uintptr_t</span>) <span class="number">0xff</span> &lt;&lt; (<span class="number">8</span> * (<span class="keyword">sizeof</span> (ret) - <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> <span class="meta-string">"BYTE_ORDER unknown"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.num;</span><br></pre></td></tr></table></figure></p><p>　　至此，我们完成对canary的基本介绍，接下来我们将通过一个demo模拟canary越界访问，也就是文章开头那个bug。</p><h3 id="3-Canary-Bug-一例"><a href="#3-Canary-Bug-一例" class="headerlink" title="3. Canary Bug 一例"></a>3. Canary Bug 一例</h3><p>　　<a href="CanaryBugDemo.rar" title="Canary Bug Demo">点击下载</a><br>　　实际工作中，除了客制化和非关键的代码会开源给客户，一些涉及关键算法的代码会以库的方式提供，这些库会在不同工程被引用，因此当底层代码更新时，特别是数据结构、数据类型发生变化是，需要及时同步头文件和库到不同的工程中，保证代码对齐。否则，会出现各种难以预料的bug，我接手这个项目处理的第一个问题就是这类问题。<br>　　我们可以看到demo中，libDemoCanary.c是以.so方式release的，其对应的头文件libDemoCanary.h。为了模拟没有对齐的情况，我再增加了一个libDemoCanary2.h，canary_demo.c包含该头文件，下图可以看到该demo差异一个char型。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/demoHeader.png" title="The difference between two headers"><br>　make产生canary_demo，执行产生coredump，当没有开启canary我们抓到的会是一个segment fault，开后会出现stack smashing detected。解析coredump如下，我们可以看到异常发生在main中，而不是发生在overWriteData()中，因为后者定义合法，内存申请大小匹配，但对于main来说，数据则超过了其栈空间，出现异常。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">donald-zhuang@ubuntu:~/Desktop/canary_demo/final$ ./canary_demo </span><br><span class="line">*** <span class="built_in">stack</span> smashing detected ***: ./canary_demo terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line"></span><br><span class="line">donald-zhuang@ubuntu:~/Desktop/canary_demo/final$ gdb ./canary_demo core </span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./canary_demo...done.</span><br><span class="line">[New LWP <span class="number">9940</span>]</span><br><span class="line">Core was generated by `./canary_demo<span class="string">'.</span></span><br><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007f27a4aac428</span> in __GI_raise (sig=sig@entry=<span class="number">6</span>) at ../sysdeps/unix/sysv/linux/raise.c:<span class="number">54</span></span><br><span class="line"><span class="number">54</span>      ../sysdeps/unix/sysv/linux/raise.c: No such file <span class="keyword">or</span> directory.</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007f27a4aac428</span> in __GI_raise (sig=sig@entry=<span class="number">6</span>) at ../sysdeps/unix/sysv/linux/raise.c:<span class="number">54</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007f27a4aae02a</span> in __GI_abort () at <span class="built_in">abort</span>.c:<span class="number">89</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007f27a4aee7ea</span> in __libc_message (do_abort=do_abort@entry=<span class="number">1</span>, fmt=fmt@entry=<span class="number">0x7f27a4c0649f</span> <span class="string">"*** %s ***: %s terminated\n"</span>) at ../sysdeps/posix/libc_fatal.c:<span class="number">175</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x00007f27a4b9015c</span> in __GI___fortify_fail (msg=&lt;optimized out&gt;, msg@entry=<span class="number">0x7f27a4c06481</span> <span class="string">"stack smashing detected"</span>) at fortify_fail.c:<span class="number">37</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00007f27a4b90100</span> in __stack_chk_fail () at stack_chk_fail.c:<span class="number">28</span></span><br><span class="line">#5  0x000000000040079f in main (argc=1, argv=0x7ffd4b1bfc18) at canary_demo.c:19</span><br></pre></td></tr></table></figure></p><p>　　具体解析，gdb运行demo，在17行处打断点，反汇编，抓取寄存器和内存信息。通过*main&lt;+4&gt;可以看到，main的栈帧申请了0x30字节，main&lt;+30&gt;可知stSrc起始在sp-0x10处，可用空间为0x20 - 0x8 = 0x18 bytes。抓寄存器信息，通过RBP获得进程的canary为0xb06404f1 a278ee00。通过RSP dump栈内数据，可以到此时的canary是正常的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /m</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line"><span class="number">14</span>      &#123;</span><br><span class="line">   <span class="number">0x0000000000400746</span> &lt;+<span class="number">0</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x0000000000400747</span> &lt;+<span class="number">1</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x000000000040074a</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x30</span>,%rsp</span><br><span class="line">   <span class="number">0x000000000040074e</span> &lt;+<span class="number">8</span>&gt;:     mov    %edi,<span class="number">-0x24</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400751</span> &lt;+<span class="number">11</span>&gt;:    mov    %rsi,<span class="number">-0x30</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400755</span> &lt;+<span class="number">15</span>&gt;:    mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">   <span class="number">0x000000000040075e</span> &lt;+<span class="number">24</span>&gt;:    mov    %rax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400762</span> &lt;+<span class="number">28</span>&gt;:    xor    %eax,%eax</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>          <span class="keyword">canary_data_t</span> stSrc;</span><br><span class="line"><span class="number">16</span>          <span class="built_in">memset</span>(&amp;stSrc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">canary_data_t</span>) );</span><br><span class="line">   <span class="number">0x0000000000400764</span> &lt;+<span class="number">30</span>&gt;:    lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x0000000000400768</span> &lt;+<span class="number">34</span>&gt;:    mov    $<span class="number">0x18</span>,%edx</span><br><span class="line">   <span class="number">0x000000000040076d</span> &lt;+<span class="number">39</span>&gt;:    mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">   <span class="number">0x0000000000400772</span> &lt;+<span class="number">44</span>&gt;:    mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x0000000000400775</span> &lt;+<span class="number">47</span>&gt;:    callq  <span class="number">0x400620</span> &lt;<span class="built_in">memset</span>@plt&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>          overWriteData(&amp;stSrc);</span><br><span class="line">=&gt; <span class="number">0x000000000040077a</span> &lt;+<span class="number">52</span>&gt;:    lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x000000000040077e</span> &lt;+<span class="number">56</span>&gt;:    mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x0000000000400781</span> &lt;+<span class="number">59</span>&gt;:    callq  <span class="number">0x400600</span> &lt;overWriteData@plt&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">0x0000000000400786</span> &lt;+<span class="number">64</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"></span><br><span class="line"><span class="number">19</span>      &#125;</span><br><span class="line">   <span class="number">0x000000000040078b</span> &lt;+<span class="number">69</span>&gt;:    mov    <span class="number">-0x8</span>(%rbp),%rcx</span><br><span class="line">   <span class="number">0x000000000040078f</span> &lt;+<span class="number">73</span>&gt;:    xor    %fs:<span class="number">0x28</span>,%rcx</span><br><span class="line">   <span class="number">0x0000000000400798</span> &lt;+<span class="number">82</span>&gt;:    je     <span class="number">0x40079f</span> &lt;main+<span class="number">89</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040079a</span> &lt;+<span class="number">84</span>&gt;:    callq  <span class="number">0x400610</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040079f</span> &lt;+<span class="number">89</span>&gt;:    leaveq </span><br><span class="line">   <span class="number">0x00000000004007a0</span> &lt;+<span class="number">90</span>&gt;:    retq   </span><br><span class="line"></span><br><span class="line">(gdb) i registers </span><br><span class="line">rbp            <span class="number">0x7fffffffe3a0</span>   <span class="number">0x7fffffffe3a0</span></span><br><span class="line">rsp            <span class="number">0x7fffffffe370</span>   <span class="number">0x7fffffffe370</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">2</span>x <span class="number">0x7fffffffe3a0</span><span class="number">-0x8</span></span><br><span class="line"><span class="number">0x7fffffffe398</span>: <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x7fffffffe370</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe390</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe3a0</span>: <span class="number">0x004007b0</span>      <span class="number">0x00000000</span>      <span class="number">0xf782b830</span>      <span class="number">0x00007fff</span></span><br></pre></td></tr></table></figure></p><p>　　单步执行进入overWriteData，对16、17行打断点,执行同main函数的步骤，我们可以看到overWriteData函数的帧大小为0x40，因此在0x7fffffffe320到0x7fffffffe35F之间，对stDes的操作不会踩到canary，在执行memcpy之前，main和overWriteData的栈内存如下。两个canary都完好。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>x <span class="number">0x7fffffffe360</span><span class="number">-0x8</span></span><br><span class="line"><span class="number">0x7fffffffe358</span>: <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">32</span>x <span class="number">0x7fffffffe320</span>  </span><br><span class="line"><span class="number">0x7fffffffe320</span>: <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span>      <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span></span><br><span class="line"><span class="number">0x7fffffffe330</span>: <span class="number">0xf7de7ab0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe340</span>: <span class="number">0xff000000</span>      <span class="number">0x00000000</span>      <span class="number">0xff000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe350</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe360</span>: <span class="number">0xffffe3a0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00400786</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe390</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br></pre></td></tr></table></figure></p><p>　　单步执行到返回语句处，在执行完cpy操作后，我们可以看到此时，main函数的栈canary已经被踩，而overWriteData则完好，因此后者返回时正常，但返回到main函数时，在从main函数返回时，canary检测到越界访问，因此coredump退出，问题出现。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">Breakpoint <span class="number">3</span>, overWriteData (stSrc=<span class="number">0x7fffffffe380</span>) at libDemoCanary.c:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">(gdb) x/<span class="number">32</span>x <span class="number">0x7fffffffe320</span></span><br><span class="line"><span class="number">0x7fffffffe320</span>: <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span>      <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span></span><br><span class="line"><span class="number">0x7fffffffe330</span>: <span class="number">0x0000000a</span>      <span class="number">0x00000014</span>      <span class="number">0x0000001e</span>      <span class="number">0x00000028</span></span><br><span class="line"><span class="number">0x7fffffffe340</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe350</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe360</span>: <span class="number">0xffffe3a0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00400786</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x0000000a</span>      <span class="number">0x00000014</span>      <span class="number">0x0000001e</span>      <span class="number">0x00000028</span></span><br><span class="line">0x7fffffffe390: 0x00000000      0x00000000      '0x00000000'    0xb06404f1</span><br></pre></td></tr></table></figure></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>　　通过上面这个bug，我过了一遍GCC的缓冲区溢出攻击保护机制，实际也学到了好些新的知识，毕竟这么底层的东西，平时也是比较少会接触到的。这时候也发现GDB在这种场景分析中十分实用。我在学习C++的虚函数原理时，也通过x/32i看到可执行代码部分的实现，收获颇多，多接触这种底层机理的了解也有助于我们更进一步写出好的程序。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>PLAYING WITH CANARIES <a href="https://www.elttam.com.au/blog/playing-with-canaries/" target="_blank" rel="noopener">https://www.elttam.com.au/blog/playing-with-canaries/</a><br>canary analysis <a href="https://hardenedlinux.github.io/2016/11/27/canary.html" target="_blank" rel="noopener">https://hardenedlinux.github.io/2016/11/27/canary.html</a><br>Stack Smashing Protector <a href="https://wiki.osdev.org/Stack_Smashing_Protector" target="_blank" rel="noopener">https://wiki.osdev.org/Stack_Smashing_Protector</a><br>Stack Smashing On A Modern Linux System <a href="https://www.exploit-db.com/papers/24085/" target="_blank" rel="noopener">https://www.exploit-db.com/papers/24085/</a><br>函数调用过程探究 <a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html" target="_blank" rel="noopener">http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html</a><br>fs:0x28介绍 <a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　处理一个开机coredump问题时，发现是一个必现canary问题，即内存越界访问。一般这类问题发生在数组越界访问，不过这次出现的rootcause有所不同，为代码未对齐导致结构体没对齐，继而在数据传输过程中出现访问越界。bug简单，但鉴于canary是一个有趣的设计，犹如人体免疫系统的表层屏障，能有效规避一些bug，因此我便萌生兴趣系统地了解这个机制，相关学习记录成此文。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="canary" scheme="https://donald-zhuang.github.io/tags/canary/"/>
    
      <category term="coredump" scheme="https://donald-zhuang.github.io/tags/coredump/"/>
    
      <category term="__stack_chk_fail" scheme="https://donald-zhuang.github.io/tags/stack-chk-fail/"/>
    
  </entry>
  
  <entry>
    <title>春秋</title>
    <link href="https://donald-zhuang.github.io/2018/07/08/ChunQiu/"/>
    <id>https://donald-zhuang.github.io/2018/07/08/ChunQiu/</id>
    <published>2018-07-09T02:19:48.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文源自我发在知乎上的一篇回答，16年年初，LP推荐我春秋这首歌，自此开始喜欢张敬轩，也开始入坑林夕。春秋是我最喜欢的一首歌，对其“备胎词”之说的不认同最终推动我写下了知乎的回答（ <a href="https://www.zhihu.com/question/29927847/answer/87183394" target="_blank" rel="noopener">張敬軒的《春秋》歌詞講的是什麼呢？</a> ）。<br>　　截止目前，这首歌不同版本我听了快四千遍，余音绕梁，便对原答案稍加修整，作成此文。同时，私以为好歌手的歌喉是这世间最独一无二的乐器，而轩在这首体现得很好。<br><a id="more"></a><br>　　在我看来，一首好歌得以扣人心弦，有三个不可或缺的因素：动人的旋律、能引起共鸣的歌词、演绎者恰到好处的感情投入。<br>　　春秋曲出Edmond Tsang，有古典乐的味道，节拍密集流畅，曲调循序渐进，华丽动人，每每品味都有不同的感觉。在其诸多版本中，港乐版最为大气磅礴，结尾的弦乐也画龙点睛，回味无穷，如网友评论，“情歌唱出史诗的感觉”。同时，轩对这首歌的演绎也无可挑剔——感情到位，唱功完美，两者也相结合得很好，有网友评港乐版live“惨得荡气回肠”，实至名归。<br>　　曲子引人，词则留人。春秋词很开放，也很流畅，感性与理性的纠缠，本心和超脱的挣扎，深深的悲伤和最后的开悟，其开放让不同人得以听出不同感觉，对其拥有不同的见解，而我自然也有所偏好。<br>　　不少人将这首词等同钟无艳、七友，我则不敢苟同，因为倘若如此，词中便有相当多反讽，一个“失意”不愿“制造恨意”的人不应如此。再看钟无艳、七友两首，夕爷也无反讽的格调，其风格更多是一种自卑，卑微如尘土。因此，这首当是“得不到”的老生常谈，并在悲痛中自我开导。<br>　　如下便是是不才对词的见解，</p><blockquote><p>那夜谁将酒喝掉 因此我讲得多了<br>然后你摇着我手拒绝我　动人像友情深了<br>我没权终止见面　只因你友善依然<br>仍用接近甜蜜那种字眼通电<br>没人应该　怨地怨天<br>得到这结局　难道怪罪神没有更伪善的祝福</p></blockquote><p>　　那天，我借酒意表达爱意，无奈她仅当自己是蓝颜，我们之间的关系只有友情而非爱情，她也因此不希望拒绝伤到我而“友善依然”。拒绝了却“仍用接近甜蜜那种字眼通电”，很多人备胎之说也源于此。拒绝了，为何还友善依旧、为何还甜蜜通电？其实“甜蜜”只是爱恋让自己捕风捉影假想她对自己不同寻常的好，自己其实也很清楚，所以才是“接近甜蜜”。<br>　　我喜欢你，你对我无意，可我还和你做着朋友，总让我觉得还有一丝机会。理性的自己清楚不可能，而且这也许已是最好的结果了，多少人在表白后连朋友都做不成，而今我们两个人之间还有友谊不是很好吗？所以“伪善的祝福”不是反语，只是一种心酸的抱怨。难道我能“怪罪”上天给我这种“祝福”是“伪善”的吗？不能，“没人应该怨天怨地，得到这种结局”。</p><blockquote><p>我没有为你伤春悲秋不配有憾事<br>你没有共我踏过万里不够剧情延续故事</p></blockquote><p>　　悲伤过后，思绪回到当下。当喜欢上一个人时，伊人一颦一笑，内心便掀起阵阵波澜。“天下何人限，慊慊只为汝”，心里只装着一个你，在美好时刻想你，在难过时念你，当你不开心时，辗转反侧，多么希望承受这一切的是自己。你的一切不就是我的春秋大事吗？<br>　　只不过这一幕幕都是独角戏，我的“伤春悲秋”，更多是自己内心的纠缠和幻想，自认爱得轰轰烈烈，在别人眼里，这种爱却未免太“幼稚”。我未曾为你真正付出恋人般的付出，也没与你真正共同经历过风雨飘摇，在你那里也许我连你日记的一句都未曾出现。</p><blockquote><p>头发未染霜　着凉亦错在我幼稚　应快活像个天使<br>有没有运气再扮弱者　玩失意<br>有没有道理为你落发必须得到世人同意<br>心灰得极可耻　心伤得无新意<br>那一线眼泪　欠大志</p></blockquote><p>　　于是开始慰藉自己，我未曾为你而爱得头生华发，在被你拒绝后，我也多么想像以前“弱者”、“失意”时有你的关心和陪伴。此时的我也悲伤绝望到连落发出世的心思都有了。这种悲伤却又依旧是自顾自，大丈夫为情所困，心伤至此，这种“心灰得极可耻，心伤得无新意”，多幼稚。深深自嘲，这眼泪也掉得太过无志。</p><blockquote><p>爱若能堪称伟大　再难挨照样开怀<br>如令你发现为你而活到失败<br>令人不安　我品性坏</p></blockquote><p>　　我也突然明白，真正的爱，再难捱也应该在爱人面前表现得坦然轻松，而不让她担心。如果让你发现我对你的爱如此悲哀堕落，让你不安，是我品性太坏了。此刻我也醒悟到，这种痛苦只是自己内心的折磨，反问自己，“若（你）自觉（自以为）这叫痛苦，未免过分容易”，实际上“应快活像个天使”。</p><blockquote><p>我没有被你改写一生怎配有心事<br>我没有被你害过恨过写成情史　变废纸<br>春秋只转载要事　如果爱你欠意义<br>这眼泪　无从安置</p></blockquote><p>　　开导自己，我没有爱你爱到为你做出“改写一生”的事，也没能在你心中留下一段刻骨铭心的回忆，哪配有心事，也未曾“被你害过恨过”写进你的“春秋”，变成一段被你痛弃的记忆。“春秋只转载要事”，而我对你的爱恋缺了那么多经历和意义，这心事（眼泪）无从安置。</p><blockquote><p>我没有运气放大自私的失意<br>更没有道理在这日你得到真爱制造恨意<br>想心酸　还可以　想心底　留根刺<br>至少要见面上万次</p></blockquote><p>　　“我没有运气放大自私的失意”，将自己的失意放大到惊天动地（内心确实惊天动地，也许天翻地覆不为过），也不该在你得到真爱的今天心生恨意，“想心酸，还可以，想心底留根刺，至少要见面上万次”，这一句应是全句的点睛之笔，总结了男主的觉悟，我心酸，是因为此时爱的人有了自己的Mr. Right，而那个人不是我。但我也没跟她一起经历刻骨铭心的爱情，所以我对她的爱却也无法在心中留下一根“刺”。这“刺”应是什么感觉呢？也许可以用婚纱背后里女主那种心态来描述。也许经历了无数的聚散离合，才能算得上真的刻骨铭心的爱情。<br>　　借用尘埃落定歌词，这首说的就是“无爱可失 得不到相恋别说失恋”。这词里很多只是为了押韵而加，林夕曾说过，他还是会先考虑押韵的要求，所以我觉得词句词义也没必要一一深究。<br>　　这首词的确很惨，感性的悲伤用理性去疗伤，就像往伤口上涂双氧水、涂酒精的感觉，不过夕爷开这一方解药，虽痛却也是有效。<br>　　在这里也希望那些还在悲伤的人们一句，如果你痛苦，请相信，未来会有一个人能够治愈你的痛苦。如果你觉得此生无法恋上第二个人，也许只是悲伤遮住了你的眼，挣开双眼吧，因为会有那么一个人让你再相信爱情的。</p><p>再借用张爱玲《半生缘》收尾</p><blockquote><p>“我要你知道，在这个世界上，总有一个人是会永远等着你的。无论什么时候，无论在什么地方，总会有这么一个人。”</p></blockquote><p>PS:同风格的还有一首尘埃落定，妥妥春秋终章，有兴趣可以听下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文源自我发在知乎上的一篇回答，16年年初，LP推荐我春秋这首歌，自此开始喜欢张敬轩，也开始入坑林夕。春秋是我最喜欢的一首歌，对其“备胎词”之说的不认同最终推动我写下了知乎的回答（ &lt;a href=&quot;https://www.zhihu.com/question/29927847/answer/87183394&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;張敬軒的《春秋》歌詞講的是什麼呢？&lt;/a&gt; ）。&lt;br&gt;　　截止目前，这首歌不同版本我听了快四千遍，余音绕梁，便对原答案稍加修整，作成此文。同时，私以为好歌手的歌喉是这世间最独一无二的乐器，而轩在这首体现得很好。&lt;br&gt;
    
    </summary>
    
      <category term="所思" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="所思" scheme="https://donald-zhuang.github.io/tags/%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>满师 - 香港理工大学毕业设计展</title>
    <link href="https://donald-zhuang.github.io/2018/06/23/From-The-Den/"/>
    <id>https://donald-zhuang.github.io/2018/06/23/From-The-Den/</id>
    <published>2018-06-23T15:20:16.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<img src="/2018/06/23/From-The-Den/vi.jpg" title="PolyU Design Annual Show 2018"></p><p>　　周六和boss双人游HK，主要是去吃和逛，吃了兰芳园、麦奀云吞面、佳佳甜品、妈咪鸡蛋仔等等。讲真，云吞面和丝袜奶茶一直是必吃的，加上都是老店，所以感觉不差。佳佳甜品则是杨枝甘露卖完，然后我跳过芝麻糊和杏仁露点了木瓜炖银耳，真心鄙视下自己，只能下次再补回来了。<br>　　除了吃的，就是逛。逛中大和理大，其中最大的收获是理大的满师毕业展。不得不说，这次年展的内容和质量不错，不少设计关心环境保护、可持续、老龄化等社会问题，相信内地也将需要面对和克服这些问题。<br>　　我个人感兴趣的方向是交互设计、产品设计、环境和室内设计以及相关科技类作品，因此脑袋装的基本是这些。其实，在其他专题也有不少亮点，比如多媒体设计部分，我看了两部片，同时pick 失物认领处的创意。<br>　　不过，隔了一个星期，现在写起上周的展览观感也不是很顺，哈哈，今日事今日毕是有道理的。<br><a id="more"></a></p><hr><p>　　香港理工大学这次毕设年展主题是满师，VI是一个狮头，实物在一楼展厅入口处摆放着。其理念在官方的宣传上如下：</p><blockquote><p>学满出师，乃学途上的一大里程碑。今届年展以[满师]为主题，标志着设计学生修毕课程，正式踏入社会的新一页；<br>好比幼狮离巢，怀着雄心等待机会一鸣惊人。理大设计就如狮子巢穴，为培育设计师提供上佳环境。<br>[师]与[狮]谐音，年展采用本地精心制作的南狮狮头做主视觉，配合其巧妙细节塑造了一套形象系统，代表各个设计科目。<br>传统南狮亦寓意[伊始的好运]，在此祝各毕业生事业一帆风顺。<br>设计：黄雋溢</p></blockquote><p>　　展览的分区情况如下，具体可参见<a href="https://www.polyudesignshow.com/floorplans/" target="_blank" rel="noopener">PolyU Design Show官网</a>介绍。</p><img src="/2018/06/23/From-The-Den/guide.jpg" title="Guide Map For PolyU Design Annual Show 2018"><p>　　每层都有亮点和吸引人的地方，有一些课题也挺引人深思，比如强生(Johnson &amp; Johnson）对于动物试验的讨论，<strong>Let’s Be Honst - We have to do it even it hurts</strong>。其蓝底白字、简约风的海报设计是一个亮点。蓝白色的采用冷静人的身心，使设计整体柔和；字体中多种动物的嵌入贴合主题且友善化；大字体吸引注意力，下方细文阐述观点，引发思考。我挺喜欢这个展位设计，对其阐述的观点我也表示支持。</p><img src="/2018/06/23/From-The-Den/Let%27sBeHonst.jpg" title="Exhibition of job Let" alt="s be honst"><p>　　之后兼具断舍离、可持续、共享资源观念于一身的House Clipper是全场我觉得比较好玩的一个设计，之所以觉得好玩，是因为这玩意我也想过要怎么设计。相关介绍和实现如下，</p><img src="/2018/06/23/From-The-Den/HouseCllipper.jpg" title="The Poster of HouseClipper"><img src="/2018/06/23/From-The-Den/HouseCllipperObject.jpg" title="The User Journey of HouseClipper"><img src="/2018/06/23/From-The-Den/HouseCllipperObject2.jpg" title="The Real Object of House Clipper"><p>　　我们可以看第三图的实物设计，其显示部分采用带触摸功能LCD，并嵌入到抽屉上；传感器座子则内贴于抽屉壁，监控抽屉使用情况以及充当手机座子，便于存放物品时手机录入物件信息。从个人角度来说，我更愿意采用磁贴结构、带触摸面板E-Ink屏，这样便于拆装和再利用，同时降低能耗，而传感器座做手机座的功能略显鸡肋，不如换成如下，</p><blockquote><p>A. 功能加强，电子标签充电座；加WIFI通讯功能用于联网功能，减小电子标签的通讯能耗。(ESP8266)<br>B. 功能精简，只做抽屉使用情况监督功能，缩减体积。(APDS-9930)<br>C. 功能整合，其功能通过电子标签的姿态传感器来做。(MPU6050)</p></blockquote><p>　　不过，实物设计只是一个其很小的部分，我们通过Poster和User Journey可以看到App实现和功能构想。平台的wishlist和communication实现资源交换、社交；在一方面，personalized tips和Second Hand &amp; Donation实现资源的再利用。总的来说，整个设计贴合断舍离、共享和可持续的理念，是一个有趣的设计。<br>　　不过也有这玩意如果真要推广，还是有很多实际性问题需要克服。比如，设计的便利化、起始用户定位、personalized tips和second hand &amp; donation功能的实现，这些目前都只是一种假想，实作并不容易。<br>　　众所周知，香港的城市规划是非常优秀的（<a href="http://daily.zhihu.com/story/9464061" target="_blank" rel="noopener">为什么说香港是我见过最棒的城市规划？</a>），比如旺角一带，看地图会觉得有种规整的美感，基本上地图定位目的地方位和所在街道，就可以关掉地图，照着方向找到。同时在不少地方的绿化也做得非常不错，私以为香港非常有限的土地资源造就了这种相对优美的城市规划。这种环境下，毕业设计中也就会有不少这类好玩的作品，如下面这个Linger POP设计，采用平面化、具备自动复原能力的机械结构来设计公交候车座椅，提升候车体验。考虑到产品特点和维修便利，作者也采用了模块化设计理念。结合香港的现状，这个设计也有效的解决空间不足的问题。</p><img src="/2018/06/23/From-The-Den/LingerPop.jpg" title="The Poster of Design Linger Pop"><p>　　同样，下面这个Connected Chair的设计也非常有创意和设计感，其灵活的使用方式、环境友好、人文化设计，妥妥让老夫想为其点赞。设计者应该是一个萌妹子，而且还是单身的，你们很好奇我为什么知道吧？？因为她的note上面有人评论，“有咁好嘅设计思路，揾男朋友有望啦”，哈哈哈。</p><img src="/2018/06/23/From-The-Den/ConnectedChair.jpg" title="The Poster of Connected Chair"><p>　　产品设计展区中，这套名为Heriture的家具设计挺吸引我的。该设计旨在唤醒人们对过度生产、对过度消费主义(fast-consumerism)和物质主义(materialism)的警惕，借助参数化系统（parametric system）和3D打印技术为人们提供一种对旧家具修缮和复原的途径，也期望以此让更多人选择修缮和重复利用旧家具，而不是直接换新的。<br>　　下图家具上的浅绿色模块就是通过3D打印制作，旧家具通过这些模块实现重新组合、修复和再利用。这个设计的理念挺贴合我对大部分<strong>坏了的东西能修就修，当确实无法修复时才丢弃</strong>的观点，加上其具有一定的Geek风格，所以很喜欢。</p><img src="/2018/06/23/From-The-Den/Heriture-2.jpg" title="The exhibition of Heriture"><p>　　除此之外，还有一个对快递包装问题关注的设计（<a href="http://www.ebrun.com/20171211/258466.shtml" target="_blank" rel="noopener">谁将引领快递包装革命</a>）。我对这个话题感兴，一方面毕竟自己学过一点包装设计，另一方面，这个设计所尝试克服的问题确实有一定的社会价值。<br>　　不过我觉得，比快递包装更值得研究改进的就是<strong>外卖包装</strong>，这个需求量也是妥妥的。实际在一楼展厅就有一个pizza盒子设计，环境友好也很有趣。具体我就不做多介绍，大伙可以看图。</p><img src="/2018/06/23/From-The-Den/ReuseablePackaging.jpg" title="Reusable Vaccum Delivery Packaging"><img src="/2018/06/23/From-The-Den/PizzaPackaging.jpg" title="The World Make Happier By Pizza"><p>　　然后我还被一款舟的“海报”收割了，产品本身是凳子之类的用途，在洪水期间可以调整为简单的舟，用于逃生。作者已经做出产品了，不过根据演示视频来看，这玩意经不起大风浪，但看起来还是挺好玩的。</p><img src="/2018/06/23/From-The-Den/Boat.jpg" title="Affordable Life-saving Furniture for Flooding"><p>　　工作原因，我一直在思考<strong>TV未来的变革方向</strong>。我当前的想法是，<strong>TV未来是一个交互界面</strong>，可以是智能家居等的交互入口。而这次年展中，有一款名为融合（Homeny）的交互设计就是通过TV做的，其面向的是失智症这一社会问题。主体通过家具采集失智老人家居信息，整合后通过APP提供给家属了解老人的活动情况，并可客制化相关的TIPS信息，通过TV应用提示老人，实现一个24小时对失智老人的监护。同时也提供一系列温馨应用（warming reminders），如family photos功能，期望以此缓解老人脑退化。具体相关信息实现可以参考下面的海报信息。</p><img src="/2018/06/23/From-The-Den/Homeny.jpg" title="Homeny"><p>　　这次展览最可惜的应该是没有看到10楼环境和室内设计学的作品，我们上去的时候已经关了，这个是我非常感兴趣的。我也相信在香港这种环境下，其环境和室内设计也会有不少亮点，明年吧，我会再来，哈哈。<br>　　最后，送一张海报给我自己，这个也是毕设作品之一。哈哈，我们在去香港理工之前，就去了海港城的诚品书店，逼格很高的一个书店。</p><img src="/2018/06/23/From-The-Den/zhuangbi.jpg" title="The Poster for the eslite bookstore">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;img src=&quot;/2018/06/23/From-The-Den/vi.jpg&quot; title=&quot;PolyU Design Annual Show 2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　周六和boss双人游HK，主要是去吃和逛，吃了兰芳园、麦奀云吞面、佳佳甜品、妈咪鸡蛋仔等等。讲真，云吞面和丝袜奶茶一直是必吃的，加上都是老店，所以感觉不差。佳佳甜品则是杨枝甘露卖完，然后我跳过芝麻糊和杏仁露点了木瓜炖银耳，真心鄙视下自己，只能下次再补回来了。&lt;br&gt;　　除了吃的，就是逛。逛中大和理大，其中最大的收获是理大的满师毕业展。不得不说，这次年展的内容和质量不错，不少设计关心环境保护、可持续、老龄化等社会问题，相信内地也将需要面对和克服这些问题。&lt;br&gt;　　我个人感兴趣的方向是交互设计、产品设计、环境和室内设计以及相关科技类作品，因此脑袋装的基本是这些。其实，在其他专题也有不少亮点，比如多媒体设计部分，我看了两部片，同时pick 失物认领处的创意。&lt;br&gt;　　不过，隔了一个星期，现在写起上周的展览观感也不是很顺，哈哈，今日事今日毕是有道理的。&lt;br&gt;
    
    </summary>
    
      <category term="游" scheme="https://donald-zhuang.github.io/categories/%E6%B8%B8/"/>
    
    
      <category term="展览" scheme="https://donald-zhuang.github.io/tags/%E5%B1%95%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Debug Checklist</title>
    <link href="https://donald-zhuang.github.io/2018/05/02/Debug%20CheckList/"/>
    <id>https://donald-zhuang.github.io/2018/05/02/Debug CheckList/</id>
    <published>2018-05-02T19:42:03.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　经常和各种bug打交道，处理多了，也就会发现有些流程在处理不同问题都会用到，套路是也。</p><p>　　鉴于很多流程早期容易被忽略，后续debug需重新沟通了解，造成不必要的麻烦。也因此，我有想法将这些流程整理汇总，后续debug做checklist用，同时记录下来也能不断完善改进。</p><p>　　这篇目前只是搭个架子，还会不完善改进。<br><a id="more"></a></p><hr><h2 id="1-常规信息收集"><a href="#1-常规信息收集" class="headerlink" title="1. 常规信息收集"></a>1. 常规信息收集</h2><p>　　常规信息收集主要是明确异常是问题还是feature，还是环境或用户操作异常，比如可能问题在新版本上解决了，但测试人员在旧版本上测试导致未修正。另外，低概率和远程协助debug时，现场技术型FAE可能会同时对接客户和RD，在对接RD时会有大量信息被作为常识隐含于沟通中，而这种隐含信息在对接客户时，也可能会被作为常识隐含跳过，这也就会导致一些重要的操作差异或者信息被忽略，导致一些奇怪的问题现象出现。而这往往需要耗费大量时间排查。我们沟通的首要目标就是要明确前置这些隐含信息是否为真，同时明确正确的复现条件和步骤。</p><p>　　当确认是一个问题时，信息收集可以了解问题复现难度、初步判定问题范围、是否新旧版本有差等，为问题处理提供早期思路。在有问题现场的时候，信息问询也能避免为盲目保护现场影响测试进度或其他问题处理开展。在人力紧张的时候，能对这个问题进行预判，排处理优先级。</p><p>　　就常见问题而言，主要需要收集的信息有如下，这些在做bug report时就需要详细说明，是研发人员debug的根本，也能减少和测试人员的沟通次数，提升工作效率。</p><blockquote><ol start="0"><li>硬件平台、软件版本、对接人，问题预期响应和实际状态，问题复现步骤、操作手法、复现概率、还原手段</li><li>问题现场是否还有保留，初步判定问题是哪个模块的 &gt;&gt; <code>是否需要请模块owner一起debug</code></li><li>同操作对比机好坏情况，尝试复现bug，确保它确实是个bug，而不是用户或环境的error。 </li><li>该问题是否有已修过的类似异常，可以跨软件硬件平台了解，看是否有思路可以参考。</li><li>同型号机器是否有好坏版本 &gt;&gt; <code>排查为新改出来的问题，也可定位可能的修改</code></li><li>异常的log是否有收集</li></ol></blockquote><h2 id="2-问题debug"><a href="#2-问题debug" class="headerlink" title="2. 问题debug"></a>2. 问题debug</h2><p>　　面对一个BUG，无论是否解过类似问题，我们都会有一些疑问或者假设，而这些就是我们debug首先需要厘清的和确认的。这些假设中，会有不少是我们以为一定会正确，但未经验证的，比如没有跑过测试或只在特定场景做过测试，并未在当前场景测试过的。这些想当然往往也是问题常出现的地方，因此需要我们实验验证。</p><p>　　Debug期间，我们要根据假设和疑点不断做实验，实验后会出现新的结论、疑问和一些冲突点，而冲突点往往指引异常的根源所在。有些时候冲突点并未能直接指引问题根源，但却可以从反面推断最初的假设和认知正确与否，是否需要重新定位问题，更换方向下手。</p><p>　　以本地多媒体视频播放卡顿来说，常见的debug方向无非MEMC处理、BW不足、CPU loading过重三种，这三者debug方式不尽相同，处理方式也有所差异，因此我们初步定位的方向不同，debug方式便会有所差，怀疑的点便也不同，需要关注的点也就天差地别，但当实验和假设冲突时，那就需要我们根据当下已有信息做方向转换。</p><blockquote><ol start="0"><li>是否有coredump文件，能否通过coredump文件回溯异常flow和问题点。log上有哪些异常，是否可以google下？</li><li>根据已有的信息，我们能过推断出问题出现在哪个模块，大概可能在哪些接口或流程上有问题。</li><li>目前疑问是什么，假设有哪些，根据此构建实验验证</li><li>加打印或者单元测试，定位异常位置，是输入 &gt; 处理 &gt; 输出</li><li>记录实验结论和现象，是否发现异常原因或出现新的疑点</li><li>重复3和4，如果未能找到原因，重新定位问题，确定是否需要更换方向。</li></ol></blockquote><p>　　复现规律问题。</p><blockquote><ol><li>必现或高概率问题，根据现象分析产生问题原因，查模块</li><li>低概率问题尽量多测试，找复现规律转化为必现问题以便分析</li></ol></blockquote><h2 id="3-Rootcause确认和分析汇总"><a href="#3-Rootcause确认和分析汇总" class="headerlink" title="3. Rootcause确认和分析汇总"></a>3. Rootcause确认和分析汇总</h2><p>　　在debug出问题rootcause或者有临时措施时，需要对问题debug过程进行梳理，并整理问题的异常原因。这个过程主要目前是明确结论是否正确，问题是否解决到位，是否有其他潜在风险，同时也能存档相关处理过程，当再次遇到类似问题时，能提供这部分信息出来供借鉴和review，这对debug人也是一种复盘和提升。</p><blockquote><ol><li>rootcause是什么？解决措施是什么？</li><li>解决措施是否彻底解决问题还是在客户需求内解决？是否有side effect？</li><li>测试建议，是否需要完整测试？单元测试？关联模块测试？场景测试？</li></ol></blockquote><h2 id="4-常见DEBUG工具和措施"><a href="#4-常见DEBUG工具和措施" class="headerlink" title="4. 常见DEBUG工具和措施"></a>4. 常见DEBUG工具和措施</h2><h4 id="print大法"><a href="#print大法" class="headerlink" title="print大法"></a>print大法</h4><p>#### </p><h2 id="4-Code-Review检查"><a href="#4-Code-Review检查" class="headerlink" title="4. Code Review检查"></a>4. Code Review检查</h2><p>　　针对Rootcause做的fix，需要做专门的review，一方面避免fixer考虑不周和参吃不齐的上code质量，一方面方便后续问题追踪，code reviewer能在其他member遇到类似问题时，提供建议和思路。</p><p>　　在做code review之前，fixer需要做如下工作确认修改，并将相应信息提供给reviewer做参考。</p><blockquote><ol><li>有无本地编译过</li><li>有无做功能确认</li><li>有无side effect，可能会打到哪些模块，是否验证过</li><li>有无做功能开关，是否需要用项目宏隔开</li><li>有无多余的log需要拿掉</li><li>有无跨环境的lib需要确认，比如bionic和glibc是否都可编译通过并正常工作。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　经常和各种bug打交道，处理多了，也就会发现有些流程在处理不同问题都会用到，套路是也。&lt;/p&gt;
&lt;p&gt;　　鉴于很多流程早期容易被忽略，后续debug需重新沟通了解，造成不必要的麻烦。也因此，我有想法将这些流程整理汇总，后续debug做checklist用，同时记录下来也能不断完善改进。&lt;/p&gt;
&lt;p&gt;　　这篇目前只是搭个架子，还会不完善改进。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="DEBUG" scheme="https://donald-zhuang.github.io/tags/DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>TinyHttpd源码解析</title>
    <link href="https://donald-zhuang.github.io/2017/07/24/TinyHttpd%20Analysis/"/>
    <id>https://donald-zhuang.github.io/2017/07/24/TinyHttpd Analysis/</id>
    <published>2017-07-24T22:57:45.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本图解HTTP。<br>这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。<br>书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了TinyHttpd的source code来了解http协议的实现和实际工作场景。<br><a id="more"></a></p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本<a href="https://book.douban.com/subject/25863515" target="_blank" rel="noopener">图解HTTP</a>。这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>的source code来了解http协议的实现和实际工作场景。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><p>声明：这篇里面的代码并不是<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>的源码，是我自己手动临摹一遍的代码，实测跑通了。一直相信代码自己码一遍会比纯看加注释收获多一些。同时，<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>只有几百行，自己码一遍也不算什么。关于阅读tinyhttpd的source code，个人觉得可以以如下顺序展开：main –&gt; startup –&gt; accept_request –&gt; execute_cgi –&gt;了解cgi实现，因此本文就按照此顺序展开分享。</p><h4 id="主体框架-gt-main"><a href="#主体框架-gt-main" class="headerlink" title="主体框架 -&gt; main()"></a>主体框架 -&gt; main()</h4><p>main函数是整个httpd的工作框架，具体的实现流程如下， startup创建socket通信并建立端口监听 –&gt; accept等待客户端连接请求 –&gt; accept_request处理客户端http请求 –&gt; cleanup释放资源<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sever_sock = <span class="number">-1</span>;</span><br><span class="line">    u_short port = <span class="number">5277</span>;</span><br><span class="line">    <span class="keyword">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line">    <span class="keyword">pthread_t</span> newthread;</span><br><span class="line"> </span><br><span class="line">    sever_sock = startup(&amp;port); <span class="comment">//建立socket通讯，并进行端口监听</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd running on port %d\n"</span>, port);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       client_sock = accept(sever_sock,</span><br><span class="line">                            (struct sockaddr *)&amp;client_name,</span><br><span class="line">                            &amp;client_name_len); <span class="comment">// 接受客户端请求</span></span><br><span class="line">       <span class="keyword">if</span>(client_sock == <span class="number">-1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           error_die(<span class="string">"accept failed"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(pthread_create(&amp;newthread, <span class="literal">NULL</span>, accept_request, (<span class="keyword">void</span> *)&amp;client_sock) != <span class="number">0</span>) <span class="comment">// 创建子线程处理客户端请求</span></span><br><span class="line">       &#123;</span><br><span class="line">           perror(<span class="string">"pthread_create failed"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cleanup(sever_sock); <span class="comment">// 关闭socket，释放相关资源</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd stopped\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="基础通讯实现-gt-startup"><a href="#基础通讯实现-gt-startup" class="headerlink" title="基础通讯实现 -&gt; startup()"></a>基础通讯实现 -&gt; startup()</h4><p>HTTP是一个应用层协议，通过TCP/IP进行传输的。HTTP协议规定，连接请求从客户端发起，服务端提供资源响应。在客户端无请求的情况下，服务端不会主动发送响应。服务端通讯建立过程： socket创建套接字 –&gt; bind绑定套接字 –&gt; listen监听套接字 –&gt; accept等待客户端连接请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> httpd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建socket描述符：采用TCP通讯方式，在第二个参数确定的情况下，第三个参数可以传0由函数自动匹配对应协议</span></span><br><span class="line">    httpd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>( httpd == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"socket failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定套接字：绑定IP地址和端口号</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port   = htons(*port); <span class="comment">// 指定端口：若端口为0，则自动分配一个端口。将端口转换为网络字节序</span></span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//IP地址：INADDR_ANY -&gt; 服务器上所有的IP对应端口号都监听</span></span><br><span class="line">    <span class="keyword">if</span>( bind(httpd,(<span class="keyword">const</span> struct sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"bind failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 若端口为0，获取自动分配的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(*port == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span>( getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span> ) <span class="comment">// 获取套接字信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            error_die(<span class="string">"getsockname failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *port = ntohs(name.sin_port); <span class="comment">// 获取端口号： 网络字节序转主机字节序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">if</span>( listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span> ) <span class="comment">// 监听httpd，等待客户端连接请求，并设置最大可排队连接数为5个</span></span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"listen failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpd;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 请求处理 -&gt; accept_request() ####</span><br><span class="line">accept_request是这个httpd的主体。通过解析http请求，对应发送资源和响应。http请求报文主要由三部分组成： 报文首部（分请求起始行和可选的请求首部字段）、空行、报文主体。通常并不一定要有报文主体。请求报文中每一行都以回车换行（**CRLF**,即<span class="string">"\r\n"</span>）作为结束标志。</span><br><span class="line">``` html</span><br><span class="line">Method URL HTTP_Version&lt;CRLF&gt;    <span class="comment">// 请求起始行</span></span><br><span class="line">Header_Name: Header_Value&lt;CRLF&gt;  <span class="comment">// 请求首部字段，可选</span></span><br><span class="line">... ...</span><br><span class="line">Header_Name: Header_Value&lt;CRLF&gt;</span><br><span class="line">&lt;CRLF&gt;                           <span class="comment">// 空行，表示报文首部结束</span></span><br><span class="line">BODY                             <span class="comment">// 报文主体</span></span><br></pre></td></tr></table></figure></p><p>下文我们用来分析的报头首部是用wireshark抓chrome访问httpd时发出的，只有报文首部，没有报文主体。不同浏览器可能有所差异，具体可用wireshark尝试分析。<br>TinyHttpd主要是针对请求起始行进行处理。请求起始行由Method、Request-Url和Http版本信息组成，三者通过空格隔开。如下请求起始行中”GET”就是method，表示请求访问服务器的类型，用于告知服务器访问意图。”/“为URL，表示请求访问的资源，也称作Request-URL，”HTTP/1.1”表示http版本信息，用来提示客户端使用的http协议功能。<br>下面的内容为请求首部字段，是可选的，在accept_request的execute_cgi中，我们只有在处理POST请求时才会去解析这部分的内容，对于GET，我们解析请求起始行后会去清除buf中的这部分数据，避免对后续处理或者下次通讯请求造成影响。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1                // 请求起始行</span><br><span class="line">Host: 192.168.179.145:5277    // 以下为可选首部字段，格式为Header-Name： Header-Value<span class="tag">&lt;<span class="name">CRLF</span>&gt;</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br></pre></td></tr></table></figure></p><p>解析请求的具体实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *pclient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client = *(<span class="keyword">int</span>*)pclient;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> method[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, cgi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numofchars = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 获取一行请求报文，以LF（\n）作为结尾。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recieve : %s"</span>, numofchars == <span class="number">0</span> ? <span class="string">"NULL\r\n"</span> : buf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对于http报文来说，第一行即为请求起始行：method url http-version</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[i]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>) <span class="comment">// 获取请求方法</span></span><br><span class="line">        method[j++] = buf[i++];</span><br><span class="line">    method[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// strcasecmp为忽略大小写，比较字符串是否相同，相同则返回0，否则参数1长度大于参数2时返回正值，反之返回负值。</span></span><br><span class="line">    <span class="comment">// TinyHttpd只支持GET和POST两种方法</span></span><br><span class="line">    <span class="keyword">if</span>( strcasecmp(method, <span class="string">"GET"</span>) &amp;&amp; strcasecmp(method, <span class="string">"POST"</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        bad_request(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检测请求是POST还是GET，若为POST则需要CGI处理，置起对应标志</span></span><br><span class="line">    cgi = strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清除多余空格</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[j]) &amp;&amp; (j++ &lt; <span class="keyword">sizeof</span>(buf)) )  </span><br><span class="line">        ;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取URL，用于确定访问什么资源</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf)) )</span><br><span class="line">    &#123;</span><br><span class="line">        url[i++] = buf[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">'\0'</span>;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Request-URL： %s\r\n"</span>, url);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* process the request */</span></span><br><span class="line">    <span class="keyword">if</span>(cgi == <span class="number">0</span>) <span class="comment">/* method : GET */</span></span><br><span class="line">    &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="comment">// 若GET请求的URL带?,则表明有查询参数，须CGI处理</span></span><br><span class="line">        <span class="keyword">while</span>( (*query_string != <span class="string">'?'</span>) &amp;&amp; (*query_string != <span class="string">'\0'</span>) ) </span><br><span class="line">            query_string++;</span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">'?'</span>) <span class="comment">/* should be process by CGI */</span></span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">            *query_string = <span class="string">'\0'</span>;</span><br><span class="line">            query_string++; <span class="comment">//截取查询的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以上为请求起始行的解析过程。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将URL转化为本地资源路径path</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"htdocs%s"</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果path为目录则返回首页路径</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">"index.html"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"request path: %s\r\n"</span>, path);</span><br><span class="line">#endif</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//检测请求文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(stat(path, &amp;st) == <span class="number">-1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//文件不存在则清除剩余header信息，即可选首部字段部分。</span></span><br><span class="line">        <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf) )</span><br><span class="line">        &#123;</span><br><span class="line">            numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        not_found(client); <span class="comment">// 向浏览器声明没有相应资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若请求URL为路径，则返回首页</span></span><br><span class="line">        <span class="comment">// warning： 这里有一个bug，假设URL为"htdocs/index"，本地存在这个目录，</span></span><br><span class="line">        <span class="comment">// 但不存在"htdocs/index/index.html"这里会合成之后的路径就是错的</span></span><br><span class="line">        <span class="keyword">if</span>( (st.st_mode &amp; S_IFMT) == S_IFDIR )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">"/index.html"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 检测到文件具备可执行权限，当请求文件为可执行程序，则应执行对应程序获取执行结果</span></span><br><span class="line">        <span class="keyword">if</span>( (st.st_mode &amp; S_IXUSR ) ||    <span class="comment">// 文件所有者具备执行权限</span></span><br><span class="line">            (st.st_mode &amp; S_IXGRP ) ||    <span class="comment">// 用户组具备执行权限</span></span><br><span class="line">            (st.st_mode &amp; S_IXOTH ) )     <span class="comment">// 其他用户具备可执行权限</span></span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cgi[%d]: goto %s\r\n"</span>, cgi, cgi == <span class="number">0</span> ? <span class="string">"serve_file"</span>:<span class="string">"execute_cgi"</span>);</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cgi == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            serve_file(client, path); <span class="comment">// 请求文件存在且非执行，则发送文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            execute_cgi(client, path, method, query_string); <span class="comment">// 需执行CGI获取内容的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(client);     <span class="comment">//释放客户端套接字，通讯结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="执行CGI"><a href="#执行CGI" class="headerlink" title="执行CGI"></a>执行CGI</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *query_string )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]= &#123;<span class="string">'A'</span>, <span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">int</span> cgi_in[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;, cgi_out[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//声明管道通讯，用于父子进程之间的通讯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> content_length = <span class="number">-1</span>, numofchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, status;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是GET方法，则清除剩余http头</span></span><br><span class="line">        <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>,buf) ) <span class="comment">//clean the header</span></span><br><span class="line">        &#123;</span><br><span class="line">            sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(buf, <span class="string">"\n"</span>)) <span class="comment">// 解析终止条件：HTTP请求头部解析完</span></span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="number">14</span>] = <span class="string">'\0'</span>;  <span class="comment">//strlen("content-length") == 14</span></span><br><span class="line">            <span class="comment">// 解析http头请求字段，获取content-length字段值，即实体主体大小</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="number">0</span> == strcasecmp(buf, <span class="string">"content-length"</span>) ) </span><br><span class="line">            &#123;</span><br><span class="line">                content_length = atoi(&amp;buf[<span class="number">16</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(content_length == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果没有成功解析到，则表明这是一个错误请求</span></span><br><span class="line">            bad_request(client);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 响应报文，返回正确响应码200</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 200 OK\r\n"</span>); <span class="comment">// 响应报文起始行组成： HTTP-Version Status-Code Reason-Phrase</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//pipe操作必须在fork之前，这边子进程才能继承到两组文件描述符，实现父子进程之间的通讯</span></span><br><span class="line">    <span class="keyword">if</span>( (pipe(cgi_out) &lt; <span class="number">0</span>) || (pipe(cgi_in) &lt; <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建管道，fd[0]--&gt;读 fd[1]&lt;--写，创建失败则返回信息给客户端</span></span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( (pid = fork()) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//为方便理解和阅读代码，加的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDIN    (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDOUT   (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDERR   (2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> meth_env[<span class="number">255</span>], query_env[<span class="number">255</span>], length_env[<span class="number">255</span>];</span><br><span class="line">        dup2(cgi_out[<span class="number">1</span>], DEFINE_STDOUT); <span class="comment">// dup2将系统标准输出定义到cgi_out[1]</span></span><br><span class="line">        close(cgi_out[<span class="number">0</span>]);               <span class="comment">// 关闭cgi_out[0],避免误操作</span></span><br><span class="line">        dup2(cgi_in[<span class="number">0</span>], DEFINE_STDIN);   <span class="comment">// 将系统标准输入定义到cgi[0]上</span></span><br><span class="line">        close(cgi_out[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">"REQUEST_METHOD=%s"</span>, method); <span class="comment">//将请求方法保存在进程所在的环境变量中</span></span><br><span class="line">        putenv(meth_env);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( strcasecmp(method,<span class="string">"GET"</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">"QUERY_STRING=%s"</span>, query_string); <span class="comment">// GET方法需提供查询的信息</span></span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">"CONTENT_LENGTH=%d"</span>, content_length); <span class="comment">// POST方法提供主题的大小</span></span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        execl(path, path, <span class="literal">NULL</span>); <span class="comment">// 执行CGI程序,同时继承了子进程的文件描述符</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 关闭两个不会操作到的pipe，避免误操作</span></span><br><span class="line">        close(cgi_in[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_out[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; content_length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                recv(client, &amp;ch, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// POST方法需要解析报文主体实体，然后发给CGI程序</span></span><br><span class="line">                write(cgi_in[<span class="number">1</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(read(cgi_out[<span class="number">0</span>], &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="comment">// 获取CGI执行结果，并通过Socket返回客户端</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            send(client, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cgi_out[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_in[<span class="number">1</span>]);</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>); <span class="comment">// 等待所有子进程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件发送实现"><a href="#文件发送实现" class="headerlink" title="文件发送实现"></a>文件发送实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">( <span class="keyword">int</span> client, FILE *resource )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    fgets( buf, <span class="keyword">sizeof</span>(buf), resource );      <span class="comment">// 读取1024bytes数据</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(resource))                    <span class="comment">// 如果文件未EOF则继续读</span></span><br><span class="line">    &#123;</span><br><span class="line">        send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);    <span class="comment">// socket传输数据</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> numofchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="string">'A'</span>, <span class="string">'\0'</span>,&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">    <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf) )</span><br><span class="line">    &#123;</span><br><span class="line">        numofchars = sock_getline( client, buf, <span class="keyword">sizeof</span>(buf) ); <span class="comment">// 清除请求头。</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    resource = fopen(filename, <span class="string">"r"</span>);    <span class="comment">// 打开文件读取</span></span><br><span class="line">    <span class="keyword">if</span>( resource == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        not_found(client);              <span class="comment">// 资源未找到或无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        headers(client, filename);      <span class="comment">// 发送服务器响应报文首部</span></span><br><span class="line">        cat(client, resource);          <span class="comment">// 发送服务器响应实体主体</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(resource);                   <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关函数实现"><a href="#相关函数实现" class="headerlink" title="相关函数实现"></a>相关函数实现</h4><p>1、获取客户端请求报文的一行内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_getline</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((buf == <span class="literal">NULL</span>) &amp;&amp; (size == <span class="number">0</span>) &amp;&amp; (sock == <span class="number">-1</span>)) <span class="comment">// 参数合法性检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parameter error, please check %s[%d]\n"</span>, __func__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>( (i &lt; size - <span class="number">1</span>) &amp;&amp; (ch != <span class="string">'\n'</span>) ) <span class="comment">// \n是行结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = recv(sock, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n = recv(sock, &amp;ch, <span class="number">1</span>, MSG_PEEK);    <span class="comment">// MSG_PEEK可实现下次读到的，仍是此次读取到的内容</span></span><br><span class="line">                <span class="keyword">if</span>( (n &gt; <span class="number">0</span>) &amp;&amp; (ch == <span class="string">'\n'</span>) )        <span class="comment">// 若读取到的\r\n，则此次读取结束，读取到的字符为\n</span></span><br><span class="line">                &#123;</span><br><span class="line">                    recv(sock, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ch = <span class="string">'\n'</span>;                       <span class="comment">// 否则设定读取的字符为\n，读取结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、服务器响应报文实现<br>为方便代码编写和阅读，我在tinyhttpd的基础上实现了下面这个函数，专门用于发送字符到socket<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_str</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ret = send(client, str, <span class="built_in">strlen</span>(str), <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    ret == <span class="built_in">strlen</span>(str) ?  <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">"send_str error[ret = 0x%02x].\r\n"</span>, ret);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发送文件前的响应头*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)filename;</span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);          <span class="comment">// 2**表示执行成功，200表示请求被正常处理</span></span><br><span class="line">    send_str(client, SERVER_STRING);</span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);  <span class="comment">// 发送资源的MIME为text/html，即文本类型</span></span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未找到文件或无法访问文件的响应报文 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 4**的状态码表明错误是客户端引发的</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 404 NOT FOUND\r\n"</span>); <span class="comment">//404表示请求的资源不存在或服务器不提供此资源访问 </span></span><br><span class="line">    send_str(client, SERVER_STRING);</span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;HTML&gt;&lt;TITLE&gt;NOT FOUND&lt;/TITLE&gt;"</span>             <span class="comment">// 发送一个简单页面用于提示</span></span><br><span class="line">                     <span class="string">"&lt;BODY&gt;&lt;P&gt; the sever couldn't fullfill"</span></span><br><span class="line">                     <span class="string">"your request because the resource specified"</span></span><br><span class="line">                     <span class="string">"is unavailable or nonexistence."</span></span><br><span class="line">                     <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 错误请求响应报文*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bad request.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 服务器不支持对应的方法或者报文语法时，会发出错误请求报文</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 400 BAD REQUEST\r\n"</span>);  <span class="comment">// 400表示请求错误或者请求的报文中存在语法错误</span></span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;P&gt; Your browse sent a bad request,"</span></span><br><span class="line">            <span class="string">"such as a POST without a Content-Length.\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务器内部异常响应报文*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not execute.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 500 Internal Server Error\r\n"</span>); <span class="comment">// 5**为服务器错误，500表示服务器在执行请求时发生错误</span></span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;p&gt;error prohibited CGI execution.\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本图解HTTP。&lt;br&gt;这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。&lt;br&gt;书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了TinyHttpd的source code来了解http协议的实现和实际工作场景。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://donald-zhuang.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="http" scheme="https://donald-zhuang.github.io/tags/http/"/>
    
      <category term="tinyhttpd" scheme="https://donald-zhuang.github.io/tags/tinyhttpd/"/>
    
  </entry>
  
</feed>
