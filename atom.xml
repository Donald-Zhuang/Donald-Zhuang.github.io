<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>御风而行</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://donald-zhuang.github.io/"/>
  <updated>2018-11-16T12:30:37.431Z</updated>
  <id>https://donald-zhuang.github.io/</id>
  
  <author>
    <name>Donald.Zhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多进程调用同一共享库内全局变量问题简单实例——全局变量被踩debug方法辑录</title>
    <link href="https://donald-zhuang.github.io/2018/11/15/GlobalVariableInSoForMultihread/"/>
    <id>https://donald-zhuang.github.io/2018/11/15/GlobalVariableInSoForMultihread/</id>
    <published>2018-11-16T02:10:04.000Z</published>
    <updated>2018-11-16T12:30:37.431Z</updated>
    
    <content type="html"><![CDATA[<p>　　上周处理一个问题，发现一个共享对象的结构体全局变量数据异常。一开始怀疑是没dump成功，后面加log发现异常时对象被全清为0了，根据log该结构体某成员的值一会为0一会为1，也就初步定性为全局变量被踩，最终经过各种手段、法哥和kent大的助攻定位到原因，发现是一个不错的多进程环境内，共享对象全局变量问题。很好玩的一个问题，就此简要分享。<br><a id="more"></a></p><hr><p>　　<em>“错误包含丰富的信息”　—— Nassim Nicholas Taleb《Antifragile》</em><br>　　前置信息，如下log均是构造出来的，仅作模拟的例子，所以全部log的时间都是一样的，实际问题和debug过程比这篇文章描述的复杂也乱，不过一开始错误的思维定势埋坑，以及debug过程被各种打断导致debug不连续，也让我有冲动梳理这个问题的原因，借以总结一下全局变量数据异常时候的处理方法，以后做check list。</p><h3 id="1-确定是否有异常读写行为"><a href="#1-确定是否有异常读写行为" class="headerlink" title="1. 确定是否有异常读写行为"></a>1. 确定是否有异常读写行为</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 所有用到该结构体的函数入口皆加入如下打印：</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d &gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__ ,stConfig.bUsing, &amp;stConfig);</span><br><span class="line"><span class="number">2.</span> 异常<span class="built_in">log</span>如下：</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]__</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _SetXXXParams<span class="number">-644</span>          &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br></pre></td></tr></table></figure><p>　　刚开始debug加的log如上。可以看出，所有用到这个变量的函数都在同个进程同个线程（PID-2048）中执行，也就首先排除多线程并发引发的全局变量数据篡改问题。第一个要怀疑的是在这些函数中有地方去操作这个变量，于是check source code，发现整个程序只有XXX_DumpPanelInfo这个函数会去操作这个对象，大致代码如下，可见函数执行后stConfig便不会为0，那下一个需要确认的就是是否有对这个全局变量的指针引用，这种行为也可以导致数据被写坏，但review了一轮source code，发现并没有，同时也没发现有同名全局变量的存在（避免so链接过程出现全局变量覆盖问题）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XXX_DumpPanelInfo</span><span class="params">(&amp;stConfig)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">memset</span>(&amp;stConfig, <span class="number">0</span>, <span class="keyword">sizeof</span>(stConfig))；</span><br><span class="line">    stConfig.bUsing = TRUE;</span><br><span class="line">    ... <span class="comment">// 对stConfig其他成员的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-上GDB确认问题"><a href="#2-上GDB确认问题" class="headerlink" title="2. 上GDB确认问题"></a>2. 上GDB确认问题</h3><p>　　经过这第一轮debug，初步推断为其他全局变量越界踩的问题。在说明我采用的gdb debug方式之前，我们先讲下gdb的watch功能。一般而言，如果不方便review code却又想尽快抓到修改变量的地方，我们可以通过gdb watch功能来实现。但他也有局限性，具体实例如下。我们可以看出，watch适用于同进程内直接对变量访问时的监控，对于越界访问检测没有太大的助力。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">int</span> gVar[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">3</span>       <span class="keyword">int</span> gVar2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6       </span>&#123;</span><br><span class="line"><span class="number">7</span>           <span class="built_in">printf</span>(<span class="string">"gVar&gt;&gt;%p, gVar2&gt;&gt;%p\r\n"</span>, gVar,&amp;gVar2 );</span><br><span class="line"><span class="number">8</span>           gVar[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br><span class="line"><span class="number">10</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line">(gdb) watch gVar2</span><br><span class="line">Hardware watchpoint <span class="number">1</span>: gVar2</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/donald-zhuang/Desktop/demo/a.out </span><br><span class="line">gVar&gt;&gt;<span class="number">0x601040</span>, gVar2&gt;&gt;<span class="number">0x601048</span></span><br><span class="line"></span><br><span class="line">Hardware watchpoint <span class="number">1</span>: gVar2</span><br><span class="line"></span><br><span class="line">Old value = <span class="number">0</span></span><br><span class="line">New value = <span class="number">2</span></span><br><span class="line">main () at SimpleSection.c:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br></pre></td></tr></table></figure></p><p>　　不过gdb的x功能弥补上面这个缺陷的方法，就是在watch抓到变量异常的时候，第一时间查看进程内存布局。下面续上面的gdb流程，通过print gVar2的地址，我们可以在其地址减1来找到他的上家，继而定位到是谁越界了，这个例子中，我们可以看到就是gVar了，找到调用这个数组的地方，review code即可发现问题所在。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Old value = <span class="number">0</span></span><br><span class="line">New value = <span class="number">2</span></span><br><span class="line">main () at SimpleSection.c:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>           <span class="built_in">printf</span>(<span class="string">"global_uninit_var&gt;&gt;%d\r\n"</span>, gVar2);</span><br><span class="line">(gdb) p &amp;gVar2</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;gVar2&gt;</span><br><span class="line">(gdb) x/<span class="number">4</span>x <span class="number">0x601048</span><span class="number">-1</span></span><br><span class="line"><span class="number">0x601047</span> &lt;gVar+<span class="number">7</span>&gt;:      <span class="number">0x00000200</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure></p><p>　　因为其他原因，我这边的做法是在抓到异常数据的地方，也就是在SetXXX_Fmodulation-1953入口处加了一个abort，让它coredump，然后通过coredump解析当前内存布局和进程情况。解析coredump可以看到如下信息，被踩的对象就是config那一块，但其前面的对象是两个锁，还有m_vTag这个对象，通过print m_vTag这个对象，可以看到其成员数据合法、非零，故此不存在前面数据大范围越界踩到stConfig的问题。那就迷糊了，难不成是其他地方的虚地址错误然后神奇得踩到这个位置。<br><img src="/2018/11/15/GlobalVariableInSoForMultihread/memory_alloc.png" title="Memory Info"></p><h3 id="3-mprotect与kernel-hardware-breakpoint"><a href="#3-mprotect与kernel-hardware-breakpoint" class="headerlink" title="3. mprotect与kernel hardware breakpoint"></a>3. mprotect与kernel hardware breakpoint</h3><p>　　对于这种无解的问题，就要上利器了，因为我们的code中有支持kernel hardware breakpoint，所以我就直接上了，这部分有兴趣大家可以参考这篇博文<a href="https://blog.csdn.net/phenix_lord/article/details/41415559" target="_blank" rel="noopener">内核模块踩内存问题定位利器- hardware breakpoint</a>，参考的实例代码如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sample_hbp_handler</span><span class="params">(struct perf_event *bp,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct perf_sample_data *data,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">"%s value is changed\n"</span>, ksym_name);</span><br><span class="line">dump_stack();</span><br><span class="line">printk(KERN_INFO <span class="string">"Dump stack from sample_hbp_handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hw_break_module_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    </span><br><span class="line">hw_breakpoint_init(&amp;attr);</span><br><span class="line">attr.bp_addr = kallsyms_lookup_name(ksym_name);<span class="comment">//待监视的地址，指令和数据地址均可以</span></span><br><span class="line">attr.bp_len = HW_BREAKPOINT_LEN_4;</span><br><span class="line">attr.bp_type = HW_BREAKPOINT_W | HW_BREAKPOINT_R;<span class="comment">//待监视的访问类型</span></span><br><span class="line">       <span class="comment">//sample_hbp_handler为待监视的地址被访问时调用</span></span><br><span class="line">sample_hbp = register_wide_hw_breakpoint(&amp;attr, sample_hbp_handler, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR((<span class="keyword">void</span> __force *)sample_hbp)) &#123;</span><br><span class="line">ret = PTR_ERR((<span class="keyword">void</span> __force *)sample_hbp);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">printk(KERN_INFO <span class="string">"HW Breakpoint for %s write installed\n"</span>, ksym_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">fail:</span><br><span class="line">printk(KERN_INFO <span class="string">"Breakpoint registration failed\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hw_break_module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unregister_wide_hw_breakpoint(sample_hbp);</span><br><span class="line">printk(KERN_INFO <span class="string">"HW Breakpoint for %s write uninstalled\n"</span>, ksym_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　不过不幸的是，因为某些原因，code中的HW BP并没有支持好，导致没能顺利抓到异常访问行为，就此作罢。既然被踩，那还可以上一招，mprotect，这个函数是通过设置进程内页属性，来实现对内存的读写保护，因为是设置页的属性，这也就决定了该函数能保护的内存需要4K对齐且大小也需要为4K倍数。具体可参考<a href="http://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual</a>。我们的全局变量没有4K大，也就需要构造下，然后验证下问题是否还能复现，具体的操作是根据实际情况对结构体定义调整，类似如下方式塞入dummy数据，然后复现问题，加完之后发现问题依旧复现得到（我在这里怀疑人生了…后加打印发现编译器优化了结构体布局，stConfig.bUsing仍然在首部）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STCONFIG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dummy[<span class="number">4095</span>];</span><br><span class="line">    BOOL bUsing;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span> dummy2[<span class="number">4095</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　既然复现得到，那就加mprotect保护。我们必须在dump数据后对该区域进行保护，其中第三行是保证地址是4K对齐的，PROT_READ表示将该页设置为只读的。这个函数执行完后，进程内其他地方如果尝试写或执行便会引发页错误，导致coredump，这样我们也就抓到异常点了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XXX_DumpPanelInfo(&amp;stConfig);   <span class="comment">// ensure the data have been initialized</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ALIGN_SIZE (4096)  <span class="comment">// the size of page</span></span></span><br><span class="line"><span class="keyword">char</span> *pstConfig = (<span class="keyword">char</span>*)(((<span class="keyword">int</span>)(&amp;stConfig) + PAGE_ALIGN_SIZE - <span class="number">1</span>) &amp; (~(PAGE_ALIGN_SIZE<span class="number">-1</span>))); <span class="comment">// align to page size</span></span><br><span class="line"><span class="keyword">if</span>(mprotect((<span class="keyword">void</span>*)pstConfig, PAGE_ALIGN_SIZE, PROT_READ))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"protect failed!\r\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">保护执行的打印</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d &gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__, stConfig.bUsing, &amp;(stConfig.bUsing));</span><br></pre></td></tr></table></figure></p><p>　　调整后得到如下log，我们可以看到加粗的两行log，人家不仅进了两次保护，还写了两次！然后没有任何coredump。于是我在加保护之后，尝试补一个写操作，结果如期出现coredump，也就证明保护实际是起效。在这情况下，我老板提醒了我mprotect是同进程内有效，跨进程无效，故以此为根基进入下一个debug。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   &gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span>__</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _SetXXXParams<span class="number">-644</span>        &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  SetXXX_En<span class="number">-1928</span>             &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  &gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     &gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2048</span> <span class="number">2048</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   &gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span> __</span><br></pre></td></tr></table></figure></p><h3 id="4-印PID，共享库全局变量问题"><a href="#4-印PID，共享库全局变量问题" class="headerlink" title="4. 印PID，共享库全局变量问题"></a>4. 印PID，共享库全局变量问题</h3><p>　　基于各种对变量被踩debug的不合理现象，问题的本质实际在不断展露。不过我还没能抓到点，找老板指点，在如上基础上，我老板让我在log上印pid，结果如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s-%d PID(%d)&gt;&gt; stConfig.bUsing[%d] [%p]\r\n"</span>, __FUNCTION__,__LINE__, getpid(),stConfig.bUsing, &amp;stConfig);</span><br><span class="line"></span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   (PID<span class="number">-2065</span>)&gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span>__</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02.914</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _SetXXXParams<span class="number">-644</span>        (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-1846</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.146</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">03.351</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _GetStatusEx_U2<span class="number">-2009</span>       (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.265</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_En<span class="number">-1928</span>             (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Fmodulation<span class="number">-1953</span>    (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_Rdeviation<span class="number">-2034</span>     (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">06.267</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  SetXXX_En<span class="number">-1928</span>             (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.594</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  GetDataFromRegister<span class="number">-1872</span>   (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  _XXXMAP_DumpTable_U2<span class="number">-2869</span>  (PID<span class="number">-2066</span>)&gt;&gt; stConfig.bUsing[<span class="number">0</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line"><span class="number">01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo<span class="number">-1706</span>     (PID<span class="number">-2065</span>)&gt;&gt; stConfig.bUsing[<span class="number">1</span>] [<span class="number">0xea00795c</span>]</span><br><span class="line">__01<span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">08.913</span> <span class="number">2052</span> <span class="number">2052</span> I Process:  XXX_DumpPanelInfo - <span class="number">2874</span>   (PID<span class="number">-2066</span>)&gt;&gt; mprotect addr <span class="number">0xea00795c</span> &gt;&gt; <span class="number">0xea00795c</span> __</span><br></pre></td></tr></table></figure></p><p>　　打印相关进程的PID信息如下，根据进程文件可知，如下多个进程都是同一个bin档实现的服务，然后经过2052的logwrapper将log打印出来，因此log上的PID都是logwrapper的，至此问题也昭然若揭，上面debug的各种不合理之处也就有了明确的解释了。如上所看为何变量地址一样，为何Mprotect“起效和失效”，在这里可以看到，是一个典型的动态库内全局变量问题。</p><blockquote><p>console:/# busybox ps | grep Process<br>1984 0        0:00 /application/bin/Process<br>2052 0        0:00 {logwrapper}/application/bin/Process<br>2065 0        0:43 /application/bin/Process<br>2066 0        6:52 {ServiceAProcess}/application/bin/Process<br>2067 0        0:00 {ServiceBProcess}/application/bin/Process</p></blockquote><p>　　关于这个问题，本质是共享对象中的全局变量会在可执行档中有一个副本，并且实际运行中采用的便是这个副本，不同进程对同一个共享对象的全局变量引用是各自独立的。我前阵子看的程序员自我修养第196面中，有如下解释</p><blockquote><p>由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来，为了能使得链接过程正常进行，链接器会在创建可执行文件时，在它的.bss段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的bss段中还有一个副本，如果同一变量同时存在于多个位置中，这在程序的实际运行过程中肯定是不可行的。<br>于是解决办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。elf共享库编译时，默认都把定义在模块内部的全局变量当做定义在其他模块的全局变量。…</p><ul><li>——《程序员的自我修养》P196*</li></ul></blockquote><h3 id="5-终章，我要去赶飞机了"><a href="#5-终章，我要去赶飞机了" class="headerlink" title="5. 终章，我要去赶飞机了"></a>5. 终章，我要去赶飞机了</h3><p>　　至此问题也就解决了，根本原因也就是两个不同的进程对同一个共享库的全局变量进行引用，而我们的多个服务进程是基于同一个bin通过不同参数启动，coder没有注意到两个module不在同个service进程中，导致采用的全局变量没能正确初始化，继而导致异常的发生。当然实际问题比这个更复杂，debug理清过程也花了我两天的时间，不过这次也是有收获的，哈哈，读书有用啊。我要赶飞机了，梳理就暂时到此，下次再调整下文章和引用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　上周处理一个问题，发现一个共享对象的结构体全局变量数据异常。一开始怀疑是没dump成功，后面加log发现异常时对象被全清为0了，根据log该结构体某成员的值一会为0一会为1，也就初步定性为全局变量被踩，最终经过各种手段、法哥和kent大的助攻定位到原因，发现是一个不错的多进程环境内，共享对象全局变量问题。很好玩的一个问题，就此简要分享。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="gdb" scheme="https://donald-zhuang.github.io/tags/gdb/"/>
    
      <category term="mprotect" scheme="https://donald-zhuang.github.io/tags/mprotect/"/>
    
      <category term="hardware breakpoint" scheme="https://donald-zhuang.github.io/tags/hardware-breakpoint/"/>
    
  </entry>
  
  <entry>
    <title>《见识》观后</title>
    <link href="https://donald-zhuang.github.io/2018/08/11/enlarge-Vision/"/>
    <id>https://donald-zhuang.github.io/2018/08/11/enlarge-Vision/</id>
    <published>2018-08-11T13:34:10.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　前阵子公司活动，我参与投稿为部门赢得一小笔活动经费，部长让我选一份100元内的礼物作为奖品鼓励，最终我选了吴军老师的两本书《智能时代》和《见识》。就在上个月，我看完了《见识》，鉴于以往看书都是找寻书中最有益于自己的一点加以实践，化为己用，其他观点仅作参考，对于好书则会闲时再翻阅。近来却也发现，这种方法读下来，很多书读完就忘，理解流于表面，没能真正看懂一本书。也因此，我决定换个方式读书，即在看完之后，将自己的体会写出来，再慢慢咀嚼消化，真正去感受这本书，不再走马观花，希望这样能有更好的效果。见识这本书，也将是我这么实践的第一本。<br><a id="more"></a></p><hr><p>　　见识，我豆瓣给分4星，有名气的加分因素。在此之前，《浪潮之巅》和《数学之美》让我吴军老师科普方式很是喜欢，也就对这本抱有一定的期待。此次看完确有所获，自觉书中有些内容值得分享，但书中也有部分内容用吴老师的话说，“尽是些绝对正确，但又毫无用处的大道理。”因此是一本中等质量的书。对这本书的简单总结，我觉得豆瓣网友 <a href="https://www.douban.com/people/suochristine/" target="_blank" rel="noopener">violet&amp;blue</a>做得很好，具体如下。其中几点我亲身实践过，受益匪浅，也贴出来与君共享。</p><blockquote><p>1、最有效的沟通是第一时间直接给出答案，然后补充解释（金字塔原理）；<br>2、做事要积极，做公司的主人，而非过客；<br>3、用OKR的方式去管理工作和生活；<br>4、凡事做记录；<br>5、少做事，把事情做好（排优先级）；<br>6、钱的本质是对各种资源的所有权和使用权的量化度量；<br>7、讲话的人有责任保证信息按时、准确地送达对方，并确认对方收到；<br>8、每件事都要产生应该的的效果，不做无用功；<br>9、有风险意识，多思考</p></blockquote><p>　　序言部分，吴军讲起他对命运的理解，“所谓命就是一个人看问题和做事情的方法”，它“主要取决于两个因素，环境的因素和我们自己对未来走向划定的方向”，要命好，就需要信命和认命，“信命是知道自己有所不能，认命则是不超越命运给自己画的线，对于得不到的坦然接受”。这观点偏中性，我上周写的<a href="https://donald-zhuang.github.io/2018/08/04/my-rules/">行事三原则</a>，观点与此类似。简而言之，凡事就是要先尽人事，随后才听天命，而最高智慧是能够明了所能和所不能，对所能之事精进，对不能之事坦然接受。</p><p>　　开文提“成功只是手段，不是目的”，提醒我们一定要明白自己真正想要的是什么，不能为了成功而追求成功，这也是本书的最基本立足点。书中言，“成败与否取决于见识的高低，而不是自己简单的努力”，这也就是很多人追求更高见识的原因。但，众所周知，见识并不是看一本书，听几番道理就能够增长开阔的，更多来自于阅历和实践，其过程类似于论语中孔子“十有五而志于学，三十而立，四十不惑，五十而知天命，六十而耳顺，七十而从心所欲不逾矩。”也有如王国维说的治学三境界，每达到一个境界，自然会看到局限，然后精进到下一个境界，一环扣一环。就此而言，这本书讲的是如何通过一些观念常识、一些正确的判断和决策方法、一些行动，提升自己的见识，实现精进。</p><p>　　这本书的定位也就决定书中观点会多，而篇幅所限也就只能浅尝，无法深入。如公司新旧更替，这一点在浪潮中有所介绍，因此本书在讲述之时，也并未多做深入，但其中几个点串联起来，其思路也不错。吴老师说，小公司得以超越大公司在于其理念更新，大小之争是新旧时代的竞争，旧时代一定竞争不过新时代。在后面却也说，谷歌“为了避免重复IBM和微软失败的老路，佩奇才把已经成熟的果实交给他人看管，自己负责起最需要支持、最需要资源的新业务。”这阐述了一个现实，新旧时代的竞争，有时需要环境和各种资源的支持，不然在阶层和资源分配固话的大企业中，新的创意即便很好，也很容易胎死腹中。应对这种资源重分配问题的，除了像佩奇这种亲自下海，国内还有一个不错的理念，芬尼克兹老总宗毅的<a href="https://www.douban.com/note/616755708/" target="_blank" rel="noopener">裂变创业理念</a>， 通过员工参股公司老员工内部裂变创业，一方面能很好选拔人才，留住人才，鼓励员工创新，另一方面也能进一步扩展公司的业务，其间的新人组也能很好看到新生代的理念和需求，感知潜在的可能，是一种成熟而又安全的企业发展机制，我也曾有幸参与一次现场活动，方式新颖也很安全。</p><p>　　关于好产品的定义，吴老师认为首先是要功能好，其实要让大家认可相应的品牌。这点好理解，首先假设价格皆可接受，质量不好的产品在市场上经过一段时间自然会被质量好的淘汰；相同质量的两种产品，人们则会接受品牌名气高一点的。常识里，好品牌除了有质量上的保证，遇差的风险低，免去选择的苦恼，更重要还有一点摩拜单车王晓峰说得很好，“一个客户买一个产品与否，功能、性价比、好友等都是次要的，最重要的是有面子。”<a href="http://www.sohu.com/a/123231990_592170" target="_blank" rel="noopener">1</a>不少品牌的价值就在于他满足了很多人的面子，用户就愿意买单了，比如海底捞、苹果手机等。</p><p>　　回到IT产品，吴老师认为IT产品被市场认可需要经历三个阶段，第一阶段，有好想法但产品问题多，只有技术敏感的人才会去关注和使用；第二阶段是解决第一阶段的可靠性和稳定性问题，但成本高掩盖了技术上的优势，影响其推广；第三阶段，解决价格问题，普及大众。这也就是“第三眼美女”的概念，任何过不了第三眼的产品都不算好的产品。不过私以为，这三个过程还需伴随着市场的成熟，有一些优秀的产品因为市场的不成熟，其理念过于超前，不能为市场所接受，最终不能得到成功的推广，这样的例子比比皆是(<a href="http://news.mydrivers.com/1/192/192836.htm" target="_blank" rel="noopener">十大因理念超前而惨败的公司</a>)。</p><p>　　除了上面提及王晓峰的一个观点，书中也提及了王晓峰的另外两个销售智慧，“销售的本质是把钱收回来，把钱收回来的地位高于把东西卖出去；持续的生意——让顾客把买的东西用光”，前一点讲的就是卖出去只是手段，而收回来才是目的。我们公司在这部分采用一种代理机制避开风险，芯片通过代理商卖给客户，代理商跟我们拿芯片是现付(不完全现付)，而代理商那边给到客户则是可延期付账，因此前阵子乐视的拖账风波并未真正影响我司。</p><p>　　对于第二点，吴老师拓展到团队管理，“管理一个团队时，你给员工的奖励不能仅仅是一次充值的促销，然后让他们享受很多年，而是想办法让他们消耗掉这种物质和精神上的奖励，能够继续轻装奋斗。”我司的奖励体系便是如此，工资够养活自己，而每年的奖金却是最浓墨重彩的一笔，而每次奖励评估的是过去半年你的表现和做过什么，每次评价完之后一切归零，从头开始。这个机制支撑了多少人的拼搏向前，犹如悬线萝卜一根。</p><p>　　回到最近，网上疯传谷歌即将回归中国，这也引发了谷歌百度之争的讨论。其中，网友们支持谷歌的论据可以用本书的一个说法总结，就是谷歌“将有用的信息送达每一个用户”。我也相信如果百度不做改变，谷歌回归后必将取得胜利，当然胜负之分未必就是在搜索引擎上。另外，谷歌的这个产品理念核心，Airbnb、Uber、滴滴也是如此践行，他们将有用的资源整合送达每个用户，而这些资源不是他们自己的，但取得了成功，因为他们都成功借此将产品做成了平台。</p><p>　　如上的讨论归结起来，讨论的便是商业的本质，一言概之，商业就是解决人们遇到的问题，并让用户愿意多花钱。</p><p>　　讲完这些大的，回归到小的，讲个人。在讲巴菲特的人生智慧时，书中谈到技术和艺术的区别，“技术可以通过学习不断进步，而且它有可传承性和可叠加性，也就是说徒弟不仅能学到师傅全部的技术，而且还可能做得更好。但是艺术没有这种特性。”这段指明了两个点，一个是师承关系的重要性，另一个则是点明哪些成功是可以复制的，哪些则是无法复制的。这也很好地让你明白，有何能有何不能，清楚自身优势形成强的着力点。</p><p>　　然后提出伪工作的概念，什么是伪工作？这个概念有一定的价值，因为对照这几条，反观自身，我们能避免很多把时间浪费在那些可做可不做的事情上，提高自己的效率，也能让自己找到逃离舒适区的方法。</p><blockquote><p>1、那些既不能给公司带来较大收益，又不能给用户带来价值的改进和“升级”，很多都是伪工作。<br>2、有的人，明明能够通过学习一种新技能更有效地工作，却偏偏要守着过去的旧工具工作，甚至手工操作，这种人是典型的为工作者。<br>3、做事情前不认真思考，做事时通过简单的试错方法盲目寻找答案。<br>4、做产品不讲究质量、不认真测试，上线后不停地修补，总是在花费很多的时间和精力找漏洞和打补丁。<br>5、不注重用有限的资源解决95%的问题，而是把大部分时间和精力用于纠结不必要的5%的问题。<br>6、每次开会找来大量不必要的人员旁听，或者总是去俺家那些不必要参加的会议。</p></blockquote><p>　　随后对于开发人员有一个警醒是很有价值，“如果一个开发人员不清楚自己所做的产品盈利能力如何，是非常危险的。”诚如文中所言，如果只执迷于技术，不了解自己开发的产品的盈利能力，那很容易做无用功，研发人员要站在“做什么事情能让公司最大获益”的高度去工作，这样才能真正让自己更能创造价值，更有价值，不至于被淘汰。而文中也提出一个模仿朗道五级形成的“五级工程师”概念，这个给诸位工程师们提供了一个自己定位的参考。</p><blockquote><p>第五级，一个人毕业后，经过一段时间的锻炼，能够熟练应用工程的知识和技能解决问题，独立完成所分配的工作，而不需要他人的指导。<br>第四级，需要有领导能力和在工程上把大问题化解为小问题的能力。<br>第三级，能够独立带领其他人做出一个为公司挣得利润的产品，本身必须是非常好的产品经理。<br>第二级，是能够做出先前没有的东西，世界因为他们多少有点不同。如jeff dean。<br>第一级，是开创一个产业的人，包括爱迪生、福特、贝尔等人。</p></blockquote><p>　　在方法介绍中，有谈及谷歌的OKR理念，这个理念跟我们公司的IDP(<a href="https://www.opm.gov/wiki/training/individual-development-plans.ashx" target="_blank" rel="noopener">Individual Development Plan</a>)很像，但我们过IDP都是比较个人的，个人能力太守图也是保密的，但OKR则将这种进度公开化，其方法也许值得我司参考以进一步改善当前的IDP推展困境。<br><img src="/2018/08/11/enlarge-Vision/OKR.jpg" title="OKR example"></p><p>　　这本书还有好些不错的观点和方法，比如“经营和管理的秘诀：不给选择”的观点、进度跟踪的消耗曲线模型等，不过本文不想罗列清单，因此点到即止。而读书了解到的方法和概念虽能给你现实生活提供一些助益，但也如我开篇提及的孔子，有些方法或者理念大家都懂，但践行不下去，其实这也就是见识和能力的局限。当你没到那个境界，没到那个火候，你所读就只能是一种观点，不能化为肌体的一部分。唯有知识经验进一步增长，见识开阔，你真正能理解时，自然就会用起来。所以看一本书，虽说未必能很快见效，但若有心，有朝一日，种下的种子终会萌芽成长。</p><p>　　这篇文章写下来长度超过我的预期，内容也颇为繁杂，跟书的设定有一定关联吧。最后，我也想用圣艾德蒙的名言收尾，总结本文，Study as if you were to live forever，live as if you were die tomorrom.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　前阵子公司活动，我参与投稿为部门赢得一小笔活动经费，部长让我选一份100元内的礼物作为奖品鼓励，最终我选了吴军老师的两本书《智能时代》和《见识》。就在上个月，我看完了《见识》，鉴于以往看书都是找寻书中最有益于自己的一点加以实践，化为己用，其他观点仅作参考，对于好书则会闲时再翻阅。近来却也发现，这种方法读下来，很多书读完就忘，理解流于表面，没能真正看懂一本书。也因此，我决定换个方式读书，即在看完之后，将自己的体会写出来，再慢慢咀嚼消化，真正去感受这本书，不再走马观花，希望这样能有更好的效果。见识这本书，也将是我这么实践的第一本。&lt;br&gt;
    
    </summary>
    
      <category term="所读" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E8%AF%BB/"/>
    
    
      <category term="书" scheme="https://donald-zhuang.github.io/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>行事三原则</title>
    <link href="https://donald-zhuang.github.io/2018/08/04/my-rules/"/>
    <id>https://donald-zhuang.github.io/2018/08/04/my-rules/</id>
    <published>2018-08-04T10:48:52.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　这阵子发现思考少了，浪多了，实在不该。原本想分享下上周我解不动，最后请AE team大佬帮忙解决的一道难题。原理是两个库的函数名相同且同时加载到内存中，导致执行bin档链接错误的vtable，引发coredump问题，不过昨天还是没能理解这套异常的发生机制和复现方案，所以分享不了，等我看下书，学习下再来。<br>　　今早起来时想起过往一些事，也就想到自己处事的三个基本原则，这三个原则支持我克服了诸多难题，经过各种实践后演化成为自己身体的一部分，也就觉得这个可以聊聊的。<br><a id="more"></a></p><hr><p>　　困难在我们成长道路上如影随行，每一次进步实际也是我们和困难搏斗后收获的成果。所以每当我们吐槽举步维艰之时，常会有朋友安慰道，“天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤…”。这样看来，困难只是一种试炼，让我们看到当下的极限在哪，也让我们得以体验那种无力感。倘若能审时度势，顺势而为，也终能收秦破吴，担起“大任”。</p><p>　　不过，这么多年的生活经历却也教我，有些困难真不是打打鸡血，咬咬牙就能过去的，有些时候还真需要你面对现实或破釜沉舟、或卧薪尝胆，至于结果最终也只能尽人事而听天命。对此，自己也长出一套对策，也就是开头说的三个原则，这三个原则在面临一些重要的问题时，常帮我度过一些难关。一句话总结出来就是，<strong>一切问题皆有解，一切都会过去，复盘成败。</strong></p><p>　　<strong>一切问题皆有解</strong>。实际是我对<strong>Nothing is impossible</strong>的衍生，这句话对我的启发和影响更多在于视野上。现实生活中，很多看似难以理解或者不可解的问题，实际只是我们身在庐山，不识其真面目。就好比魔术，我们觉得不可能的事情，魔术师咫尺之间呈现在你面前，还能让你看不出一丝破绽，而生活中的困难和诸多难题又何不如此。也因此，当陷入困境之时，需要时刻提醒自己，要跳开出来，用第三方的视角审查周围的一切，找出自己不理解、不确定、不可能中的可能，找到那一丝线头，抽丝剥茧寻求答案。</p><p>　　这种视野也让我发现很多让你深陷其中的难题是视野局限出来的，敢于挑战自己信仰的，反而会有更强大的进步。用马克·吐温的话说就是，<strong>“让我们陷入困境的不是无知，而是看似正确的谬误论断。”</strong>(“It ain’t what you don’t know that gets you into trouble. It’s what you know for sure that just ain’t so.”)，挑战并颠覆这样的“谬误论断”，能让你解决很多看似无解的问题。所以，困难之时，一定要坚信任何难题都有解，需要做的是冷静思考。既要看到自己的局限和无力之处，也要看到潜在的可能，不然最后就只能跟项羽一样自刎垓下。</p><p>　　<strong>一切都会过去</strong>，原文为<strong>This too shall pass</strong>。这句来自一个所罗门王的一则<a href="http://kfbck.blog.163.com/blog/static/56013136200893095455577/" target="_blank" rel="noopener">寓言故事</a>。我一直很喜欢这句话，如所罗门王期待效果一样，“它有魔力，快乐的人看见它会变得悲伤；而悲伤的人看见它会变得快乐。”，每当遇到短时无法克服的困难，无法摆脱的困境时，我便会以此安慰自己。回头想想过往那些自认难熬的时刻如何度过，再想想未来回头再看此时的感觉，一些将变得如此平淡。当自己为了一时的成绩过于骄傲时，也会心里默念一遍压压自己。这样看问题也就会用更远的视角来审视此时，一切的一切并没什么大不了的。</p><p>　　最后就是<strong>复盘成败</strong>。<a href="http://wiki.mbalib.com/wiki/%E5%A4%8D%E7%9B%98" target="_blank" rel="noopener">复盘来源于围棋术语</a>，是指下完一盘棋之后，重新在棋盘上把对弈过程走一遍，以期看清自己和对手各自短长，查漏补缺，实现棋艺的精进。我曾看过<a href="https://book.douban.com/subject/25702395/" target="_blank" rel="noopener">《复盘》</a>这本书，据说这个技巧在联想中被推行。我也曾在公司新生分享中，介绍过这个技能。我们常鼓励大家在有条件的时候多试错，而试错只是一个开头，其真正的目的在于随后的复盘和改进，《孟子·告天下》中提及，“人恒过，然后能改”，人只有多犯错或了解别人犯过的错，才能避免重蹈覆辙。</p><p>　　除了复盘败和错，同样当你克服困难、取得胜利时，也值得去复盘，借此了解相关的模式在未来可否复现并助攻自己再次取得胜利，或者反向思考，当别人采用相同的方式决战自己时，有无方法攻克。我相信这一点在大疆的Robot Master大赛中，不少团队践行得很好，因为每年我们都会发现，去年一些优秀的战略或者攻防技术，在今年会被其他队伍学习推广开来，并取得更好的效果。同样，也会有相应措施来应对这样的策略。犹如达尔文的生物进化论，优胜略汰，好的基因不断遗传进化，繁衍更加优秀的生命。</p><p>　　如上三条也就是我常提醒自己的原则或说策略，实际上复盘这条是为了不提出真正的第三条而顶上的。复盘目前我也还在学习和使用。这三条其实归结起来，前两条讲的是应对困境需要有的心态，不惧困难，寻求解决，克服不了时，也莫自甘堕落，应有卧薪尝胆之心，而最后一条则是寻求精进的策略，取一把柳叶刀剖开细看，自查自纠。人在不同阶段都会有不同的思维和决策原则，而这三条就是当下我所践行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这阵子发现思考少了，浪多了，实在不该。原本想分享下上周我解不动，最后请AE team大佬帮忙解决的一道难题。原理是两个库的函数名相同且同时加载到内存中，导致执行bin档链接错误的vtable，引发coredump问题，不过昨天还是没能理解这套异常的发生机制和复现方案，所以分享不了，等我看下书，学习下再来。&lt;br&gt;　　今早起来时想起过往一些事，也就想到自己处事的三个基本原则，这三个原则支持我克服了诸多难题，经过各种实践后演化成为自己身体的一部分，也就觉得这个可以聊聊的。&lt;br&gt;
    
    </summary>
    
      <category term="所思" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>GCC SSP Canary功能简介</title>
    <link href="https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/"/>
    <id>https://donald-zhuang.github.io/2018/07/21/Tips-About-Canary-in-GCC-SSP/</id>
    <published>2018-07-21T21:32:04.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　处理一个开机coredump问题时，发现是一个必现canary问题，即内存越界访问。一般这类问题发生在数组越界访问，不过这次出现的rootcause有所不同，为代码未对齐导致结构体没对齐，继而在数据传输过程中出现访问越界。bug简单，但鉴于canary是一个有趣的设计，犹如人体免疫系统的表层屏障，能有效规避一些bug，因此我便萌生兴趣系统地了解这个机制，相关学习记录成此文。<br><a id="more"></a><br>　　这篇文章首先会介绍canary的基本原理、使能方式、运行机制、canary值产生原理，最后通过gdb一个实例完整解析整个运行流程，阐释debug过程，后续我也争取更加详细阐述canary一些设计的深入原理和目的。Hope you can enjoy it.</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>　　我遇到的实际问题如下，可以看到<strong>__stack_chk_fail</strong>的字眼，也就是canary问题的标志，这类问题就是栈内存越界访问导致，一般出现在数组越界上，不过这次我们遇到的是代码对齐问题。debug时我看了下code，猜原因，然后对代码就找到rootcause。实际对canary熟悉后，基本可以很快定位问题。此次分析不会提供原始问题代码，毕竟直接晒公司代码是要收律师函的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0xea36bd5c in raise () from /lib/libc.so.6</span><br><span class="line">#1  0xea36f838 in abort () from /lib/libc.so.6</span><br><span class="line">#<span class="number">2</span>  <span class="number">0xea3a32cc</span> in ?? () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0xea4212e0</span> in __fortify_fail () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0xea42129c</span> in __stack_chk_fail () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0xecd173dc</span> <span class="function">in <span class="title">XXX_HAL_AUD_SetGeqEnable</span> <span class="params">(ePort=XXX_MW_SND_OUTPORT_I2S1,</span></span></span><br><span class="line">    bOnOff=XXX_TRUE) at src/xxx_hal_audio.c:976</span><br><span class="line">#<span class="number">6</span>  <span class="number">0xee9d8428</span> in XxxAudioCtrl::GEQAef::setGEQEnable (<span class="keyword">this</span>=<span class="number">0xe6400590</span>,</span><br><span class="line">    bOnoff=bOnoff@entry=XXX_TRUE)</span><br><span class="line">    at ../middleware/sdkctrl/xxx_mw_audioctrl.cpp:<span class="number">2200</span></span><br><span class="line">#<span class="number">7</span>  <span class="number">0xee9d9168</span> <span class="function">in <span class="title">setSndEffect</span> <span class="params">(pctSndModeParam=&lt;optimized out&gt;)</span></span></span><br><span class="line">    at ../middleware/sdkctrl/xxx_mw_audioctrl.cpp:423</span><br><span class="line">#<span class="number">8</span>  <span class="number">0xeeaa5efc</span> <span class="function">in <span class="title">setSndModeSetting</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ptSndModeSetting=ptSndModeSetting@entry=<span class="number">0xe587ecd4</span>)</span></span></span><br><span class="line">    at ../middleware/setting/xxx_mw_audio.cpp:4181</span><br></pre></td></tr></table></figure></p><h3 id="2-GCC-SSP的canary基本原理"><a href="#2-GCC-SSP的canary基本原理" class="headerlink" title="2. GCC SSP的canary基本原理"></a>2. GCC SSP的canary基本原理</h3><p>　　Stack Canary是GCC <a href="https://wiki.osdev.org/Stack_Smashing_Protector" target="_blank" rel="noopener">Smash Stack Protector(SSP)</a>机制的一个组成部分。通过在loader加载程序时给进程预留一个随机数，称为Canary，当进程内各个函数做栈初始化时，GCC SSP在局部变量和EBP之间插入该值，并在函数返回时，取出该值检查是否被改写，以此判定是否发生内存越界访问等相关问题。下面我们将通过一个实例来解析其实现，文章采用的系统环境如下。</p><blockquote><p>Linux version 4.4.0-119-generic (buildd@lcy01-amd64-013)<br>gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)</p></blockquote><p>　　关于测试采用的代码如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filename: Canary_demo_naive.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canaryTest</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    str[<span class="number">0</span>]  = <span class="number">0xAB</span>;</span><br><span class="line">    str[<span class="number">18</span>] = <span class="number">0xBC</span>;</span><br><span class="line">    str[<span class="number">19</span>] = <span class="number">0xEF</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    canaryTest();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-1-功能使能方式"><a href="#2-1-功能使能方式" class="headerlink" title="2.1 功能使能方式"></a>2.1 功能使能方式</h4><p>　　canary功能分两个阶段实现，</p><blockquote><ol><li>编译阶段通过相关编译开关使能SSP，在满足条件的函数中嵌入代码</li><li>在运行阶段检测实现，运行到相关代码检测是否发生栈越界访问，是则终止程序执行(abort)</li></ol></blockquote><p>　　编译阶段，通过如下编译开关控制需要在哪些函数上加保护，目前常用的开关有如下几种，相关详细介绍可以参考<a href="https://lwn.net/Articles/584225/" target="_blank" rel="noopener">“Strong” stack protection for GCC</a>, 实际还有另外两种功能，不过比较少用，不做介绍。</p><blockquote><ol><li>-fstack-protector (GCC 4.1): 当函数定义大小大于等于8字节的数组时使能Canary，当然也可以通过–param=ssp-buffer-size=N 来控制对应的起效阈值</li><li>-fstack-protector-all: 对所有非内联函数使能Canary</li><li>-fstack-protector-strong (GCC 4.9): 满足以下三个条件都会插入保护代码，相对前两种具有更好的表现，其相关历史可参考<a href="https://outflux.net/blog/archives/2014/01/27/fstack-protector-strong/" target="_blank" rel="noopener">Kees Cook blog</a><br>1) 局部变量的地址作为赋值语句的右值或函数参数；<br>2) 局部变量为数组或含数组的数据类型，忽略数组的长度和类型；<br>3) 带register声明的局部变量</li><li>-fno-stack-protector: 禁用canary功能</li></ol></blockquote><p>　　对上文的Canary_demo_naive.c采用gcc -S Canary_demo_naive.s Canary_demo_naive.c和gcc -S Canary_demo_naive-no.s Canary_demo_naive.c -fno-stack-protector，比较编译出来的差异如下。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/DiffBetweenCanaryOnOff.png" title="The difference about Canary function"><br>　　依据上图左侧汇编代码，我们可以画出如下内存分布图。初始化阶段，从FS[40]抓取一个64bit的random值(canary)保存在栈底，返回时取出该值与FS[40]比较，若该值发生变化，调用__stack_chk_fail报错退出程序。显而易见，当出现越界访问时，canary值会被改写，检测机制生效，这也就是SSP Canary的运行阶段的实现原理。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/stack.png" title="The Stack"></p><h4 id="2-2-功能缺陷"><a href="#2-2-功能缺陷" class="headerlink" title="2.2 功能缺陷"></a>2.2 功能缺陷</h4><p>　　再看回上文汇编部分。我们申请的是一个20 bytes数组，考虑canary的8 bytes，则分配时应该是28 bytes，但编译器申请的是32字节，经过几次测试我发现，编译器分配的长度是满足申请所需的最小16n bytes。<br>　　这个实现会出现什么问题呢？如果我们所需的字节数加上8刚好等于16n时，一越界，canary就会被才到，功能正常。但如果所需长度小于16n，就会出现gap，当越界访问不超越这个gap，就会出现检测不到越界的问题。Canary_demo_naive.c中越界访问str[23]是检测不到的，只有在写str[24]真正踩到canary时才会报错。</p><h4 id="2-3-canary的产生"><a href="#2-3-canary的产生" class="headerlink" title="2.3 canary的产生"></a>2.3 canary的产生</h4><h5 id="2-3-1-Canary常见类型"><a href="#2-3-1-Canary常见类型" class="headerlink" title="2.3.1 Canary常见类型"></a>2.3.1 Canary常见类型</h5><p>　　Canary的类型主要有三种，Terminator canaries、Random canaries、Random XOR canaries。后面我们可以看到GCC源码中Terminator和Random XOR有相应实现，三者区别如下。<br>　　<strong>Terminator canaries</strong>：缓冲区溢出攻击中大部分是通过字符串操作实现，基于此，Terminator Canary通过NULL、CR、LF或-1的组合形成。攻击者若想绕过Canary检查，则必须在其攻击字串中加入NULL，而strcpy类函数都是以NULL为字符串结束符，这样就成功规避了此类针对标准库函数的漏洞利用。<br>　　<strong>Random canaries</strong>：Terminator的缺点在于值固定且可知，攻击者可通过其他方式（memcpy）绕过，因此Random Canary应运而生。一般来说，Random Canary产生于一个熵值足够大的随机数发生源，在程序初始化阶段保存在一个不可读的位置，并留存在一个全局变量中，而后者也就意味着攻击者依旧有机会获取到这个值，但实际已经能隔绝大部分攻击。<br>　　<strong>Random XOR canaries</strong>：在随机数的基础上，将之与部分控制符通过XOR操作形成，这样攻击难度进一步提升，攻击者需要获取到随机数、控制符和对应算法才能获取到对应的Canary值来实现绕过。<br>　　实际上，GCC中采用了Random配合Terminator的方式实现Canary值的生成和使用。</p><h5 id="2-3-2-GCC-Canary生成原理"><a href="#2-3-2-GCC-Canary生成原理" class="headerlink" title="2.3.2 GCC Canary生成原理"></a>2.3.2 GCC Canary生成原理</h5><p>　　在了解了其工作原理和类型，接下来介绍GCC中Canary这个值的来源。我们前面提到是通过FS[40]获取到的，那FS[40]这个值又是从何而来？<br>　　因为这个值在main函数中就会被用到，因此其产生早于main函数。我们也知道，main()并不是进程运行的第一个函数，其在linux中的启动过程为 <strong>_start -&gt; <strong>libc_start_main -&gt; </strong>libc_csu_init -&gt; _init -&gt; main -&gt; _fini</strong>，更具体可以通过文章<a href="https://blog.csdn.net/gary_ygl/article/details/8506007" target="_blank" rel="noopener">linux编程之main()函数启动过程</a>了解。而<strong>__libc_start_main</strong>之后的流程实现于glibc。有这个基础后，我们可以通过glibc-2.27的源码，了解Canary值的来源。<br>　　首先我们来了解下FS这个寄存器存放的基址是什么东西，通过flow <strong><strong>libc_start_main &gt;&gt; </strong>libc_setup_tls &gt;&gt; TLS_INIT_TP</strong>，看到TLS_INIT_TP这个宏的实现如下，如下位置将%fs的基址设置为TLS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code to initially initialize the thread pointer.  This might need</span></span><br><span class="line"><span class="comment">   special attention since 'errno' is not yet available and if the</span></span><br><span class="line"><span class="comment">   operation can cause a failure 'errno' must not be touched.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We have to make the syscall for both uses of the macro since the</span></span><br><span class="line"><span class="comment">   address might be (and probably is) different.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TLS_INIT_TP(thrdescr) \</span></span><br><span class="line">  (&#123; <span class="keyword">void</span> *_thrdescr = (thrdescr);      \</span><br><span class="line">     <span class="keyword">tcbhead_t</span> *_head = _thrdescr;      \</span><br><span class="line">     <span class="keyword">int</span> _result;      \</span><br><span class="line">      \</span><br><span class="line">     _head-&gt;tcb = _thrdescr;      \</span><br><span class="line">     <span class="comment">/* For now the thread descriptor is at the same address.  */</span>      \</span><br><span class="line">     _head-&gt;self = _thrdescr;      \</span><br><span class="line">      \</span><br><span class="line">     <span class="comment">/* It is a simple syscall to set the %fs value for the thread.  */</span>      \</span><br><span class="line">     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">"syscall"</span>      \</span><br><span class="line">   : <span class="string">"=a"</span> (_result)      \</span><br><span class="line">   : <span class="string">"0"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) __NR_arch_prctl),      \</span><br><span class="line">     <span class="string">"D"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) ARCH_SET_FS),      \</span><br><span class="line">     <span class="string">"S"</span> (_thrdescr)      \</span><br><span class="line">   : <span class="string">"memory"</span>, <span class="string">"cc"</span>, <span class="string">"r11"</span>, <span class="string">"cx"</span>);      \</span><br><span class="line">      \</span><br><span class="line">    _result ? <span class="string">"cannot set %fs base address for thread-local storage"</span> : <span class="number">0</span>;     \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>　　通过上面宏我们可以看到该基址指向的数据类型为tcbhead_t，对应数据结构如下,因为我的系统是x86_64，因此计算对应的偏移可得FS[40]对应的成员是stack_guard。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">int</span> gscope_flag;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">  ........</span><br><span class="line">  <span class="keyword">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></p><p>　　而stack_guard是通过如下代码设置。其中，_dl_random为_dl_sysdep_start函数从内核获取到的一个随机数，经_dl_setup_stack_chk_guard计算生成canary，再通过THREAD_SET_STACK_GUARD宏则将canary赋值%fs:0x28。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Set up the stack checker's canary.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>　　_dl_setup_stack_chk_guard实现如下，可以看到有两种实现方式，当_dl_random为空时，Canary取值为0xff10，否则将_dl_random低8 bits置0算得canary，这样能保证最后一个字节是’\0’，也就是终止符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> __attribute__ ((always_inline))</span><br><span class="line">_dl_setup_stack_chk_guard (<span class="keyword">void</span> *dl_random)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> num;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[<span class="keyword">sizeof</span> (<span class="keyword">uintptr_t</span>)];</span><br><span class="line">  &#125; ret = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dl_random == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ret.bytes[<span class="keyword">sizeof</span> (ret) - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">      ret.bytes[<span class="keyword">sizeof</span> (ret) - <span class="number">2</span>] = <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (ret.bytes, dl_random, <span class="keyword">sizeof</span> (ret));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></span><br><span class="line">      ret.num &amp;= ~(<span class="keyword">uintptr_t</span>) <span class="number">0xff</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> BYTE_ORDER == BIG_ENDIAN</span></span><br><span class="line">      ret.num &amp;= ~((<span class="keyword">uintptr_t</span>) <span class="number">0xff</span> &lt;&lt; (<span class="number">8</span> * (<span class="keyword">sizeof</span> (ret) - <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> <span class="meta-string">"BYTE_ORDER unknown"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.num;</span><br></pre></td></tr></table></figure></p><p>　　至此，我们完成对canary的基本介绍，接下来我们将通过一个demo模拟canary越界访问，也就是文章开头那个bug。</p><h3 id="3-Canary-Bug-一例"><a href="#3-Canary-Bug-一例" class="headerlink" title="3. Canary Bug 一例"></a>3. Canary Bug 一例</h3><p>　　<a href="CanaryBugDemo.rar" title="Canary Bug Demo">点击下载</a><br>　　实际工作中，除了客制化和非关键的代码会开源给客户，一些涉及关键算法的代码会以库的方式提供，这些库会在不同工程被引用，因此当底层代码更新时，特别是数据结构、数据类型发生变化是，需要及时同步头文件和库到不同的工程中，保证代码对齐。否则，会出现各种难以预料的bug，我接手这个项目处理的第一个问题就是这类问题。<br>　　我们可以看到demo中，libDemoCanary.c是以.so方式release的，其对应的头文件libDemoCanary.h。为了模拟没有对齐的情况，我再增加了一个libDemoCanary2.h，canary_demo.c包含该头文件，下图可以看到该demo差异一个char型。<br><img src="/2018/07/21/Tips-About-Canary-in-GCC-SSP/demoHeader.png" title="The difference between two headers"><br>　make产生canary_demo，执行产生coredump，当没有开启canary我们抓到的会是一个segment fault，开后会出现stack smashing detected。解析coredump如下，我们可以看到异常发生在main中，而不是发生在overWriteData()中，因为后者定义合法，内存申请大小匹配，但对于main来说，数据则超过了其栈空间，出现异常。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">donald-zhuang@ubuntu:~/Desktop/canary_demo/final$ ./canary_demo </span><br><span class="line">*** <span class="built_in">stack</span> smashing detected ***: ./canary_demo terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line"></span><br><span class="line">donald-zhuang@ubuntu:~/Desktop/canary_demo/final$ gdb ./canary_demo core </span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./canary_demo...done.</span><br><span class="line">[New LWP <span class="number">9940</span>]</span><br><span class="line">Core was generated by `./canary_demo<span class="string">'.</span></span><br><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007f27a4aac428</span> in __GI_raise (sig=sig@entry=<span class="number">6</span>) at ../sysdeps/unix/sysv/linux/raise.c:<span class="number">54</span></span><br><span class="line"><span class="number">54</span>      ../sysdeps/unix/sysv/linux/raise.c: No such file <span class="keyword">or</span> directory.</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007f27a4aac428</span> in __GI_raise (sig=sig@entry=<span class="number">6</span>) at ../sysdeps/unix/sysv/linux/raise.c:<span class="number">54</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007f27a4aae02a</span> in __GI_abort () at <span class="built_in">abort</span>.c:<span class="number">89</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007f27a4aee7ea</span> in __libc_message (do_abort=do_abort@entry=<span class="number">1</span>, fmt=fmt@entry=<span class="number">0x7f27a4c0649f</span> <span class="string">"*** %s ***: %s terminated\n"</span>) at ../sysdeps/posix/libc_fatal.c:<span class="number">175</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x00007f27a4b9015c</span> in __GI___fortify_fail (msg=&lt;optimized out&gt;, msg@entry=<span class="number">0x7f27a4c06481</span> <span class="string">"stack smashing detected"</span>) at fortify_fail.c:<span class="number">37</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00007f27a4b90100</span> in __stack_chk_fail () at stack_chk_fail.c:<span class="number">28</span></span><br><span class="line">#5  0x000000000040079f in main (argc=1, argv=0x7ffd4b1bfc18) at canary_demo.c:19</span><br></pre></td></tr></table></figure></p><p>　　具体解析，gdb运行demo，在17行处打断点，反汇编，抓取寄存器和内存信息。通过*main&lt;+4&gt;可以看到，main的栈帧申请了0x30字节，main&lt;+30&gt;可知stSrc起始在sp-0x10处，可用空间为0x20 - 0x8 = 0x18 bytes。抓寄存器信息，通过RBP获得进程的canary为0xb06404f1 a278ee00。通过RSP dump栈内数据，可以到此时的canary是正常的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble /m</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line"><span class="number">14</span>      &#123;</span><br><span class="line">   <span class="number">0x0000000000400746</span> &lt;+<span class="number">0</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x0000000000400747</span> &lt;+<span class="number">1</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x000000000040074a</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x30</span>,%rsp</span><br><span class="line">   <span class="number">0x000000000040074e</span> &lt;+<span class="number">8</span>&gt;:     mov    %edi,<span class="number">-0x24</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400751</span> &lt;+<span class="number">11</span>&gt;:    mov    %rsi,<span class="number">-0x30</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400755</span> &lt;+<span class="number">15</span>&gt;:    mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">   <span class="number">0x000000000040075e</span> &lt;+<span class="number">24</span>&gt;:    mov    %rax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x0000000000400762</span> &lt;+<span class="number">28</span>&gt;:    xor    %eax,%eax</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>          <span class="keyword">canary_data_t</span> stSrc;</span><br><span class="line"><span class="number">16</span>          <span class="built_in">memset</span>(&amp;stSrc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">canary_data_t</span>) );</span><br><span class="line">   <span class="number">0x0000000000400764</span> &lt;+<span class="number">30</span>&gt;:    lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x0000000000400768</span> &lt;+<span class="number">34</span>&gt;:    mov    $<span class="number">0x18</span>,%edx</span><br><span class="line">   <span class="number">0x000000000040076d</span> &lt;+<span class="number">39</span>&gt;:    mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">   <span class="number">0x0000000000400772</span> &lt;+<span class="number">44</span>&gt;:    mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x0000000000400775</span> &lt;+<span class="number">47</span>&gt;:    callq  <span class="number">0x400620</span> &lt;<span class="built_in">memset</span>@plt&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>          overWriteData(&amp;stSrc);</span><br><span class="line">=&gt; <span class="number">0x000000000040077a</span> &lt;+<span class="number">52</span>&gt;:    lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line">   <span class="number">0x000000000040077e</span> &lt;+<span class="number">56</span>&gt;:    mov    %rax,%rdi</span><br><span class="line">   <span class="number">0x0000000000400781</span> &lt;+<span class="number">59</span>&gt;:    callq  <span class="number">0x400600</span> &lt;overWriteData@plt&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">18</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">0x0000000000400786</span> &lt;+<span class="number">64</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"></span><br><span class="line"><span class="number">19</span>      &#125;</span><br><span class="line">   <span class="number">0x000000000040078b</span> &lt;+<span class="number">69</span>&gt;:    mov    <span class="number">-0x8</span>(%rbp),%rcx</span><br><span class="line">   <span class="number">0x000000000040078f</span> &lt;+<span class="number">73</span>&gt;:    xor    %fs:<span class="number">0x28</span>,%rcx</span><br><span class="line">   <span class="number">0x0000000000400798</span> &lt;+<span class="number">82</span>&gt;:    je     <span class="number">0x40079f</span> &lt;main+<span class="number">89</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040079a</span> &lt;+<span class="number">84</span>&gt;:    callq  <span class="number">0x400610</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040079f</span> &lt;+<span class="number">89</span>&gt;:    leaveq </span><br><span class="line">   <span class="number">0x00000000004007a0</span> &lt;+<span class="number">90</span>&gt;:    retq   </span><br><span class="line"></span><br><span class="line">(gdb) i registers </span><br><span class="line">rbp            <span class="number">0x7fffffffe3a0</span>   <span class="number">0x7fffffffe3a0</span></span><br><span class="line">rsp            <span class="number">0x7fffffffe370</span>   <span class="number">0x7fffffffe370</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">2</span>x <span class="number">0x7fffffffe3a0</span><span class="number">-0x8</span></span><br><span class="line"><span class="number">0x7fffffffe398</span>: <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x7fffffffe370</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe390</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe3a0</span>: <span class="number">0x004007b0</span>      <span class="number">0x00000000</span>      <span class="number">0xf782b830</span>      <span class="number">0x00007fff</span></span><br></pre></td></tr></table></figure></p><p>　　单步执行进入overWriteData，对16、17行打断点,执行同main函数的步骤，我们可以看到overWriteData函数的帧大小为0x40，因此在0x7fffffffe320到0x7fffffffe35F之间，对stDes的操作不会踩到canary，在执行memcpy之前，main和overWriteData的栈内存如下。两个canary都完好。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>x <span class="number">0x7fffffffe360</span><span class="number">-0x8</span></span><br><span class="line"><span class="number">0x7fffffffe358</span>: <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">32</span>x <span class="number">0x7fffffffe320</span>  </span><br><span class="line"><span class="number">0x7fffffffe320</span>: <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span>      <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span></span><br><span class="line"><span class="number">0x7fffffffe330</span>: <span class="number">0xf7de7ab0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe340</span>: <span class="number">0xff000000</span>      <span class="number">0x00000000</span>      <span class="number">0xff000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe350</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe360</span>: <span class="number">0xffffe3a0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00400786</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe390</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br></pre></td></tr></table></figure></p><p>　　单步执行到返回语句处，在执行完cpy操作后，我们可以看到此时，main函数的栈canary已经被踩，而overWriteData则完好，因此后者返回时正常，但返回到main函数时，在从main函数返回时，canary检测到越界访问，因此coredump退出，问题出现。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">Breakpoint <span class="number">3</span>, overWriteData (stSrc=<span class="number">0x7fffffffe380</span>) at libDemoCanary.c:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">(gdb) x/<span class="number">32</span>x <span class="number">0x7fffffffe320</span></span><br><span class="line"><span class="number">0x7fffffffe320</span>: <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span>      <span class="number">0xffffe380</span>      <span class="number">0x00007fff</span></span><br><span class="line"><span class="number">0x7fffffffe330</span>: <span class="number">0x0000000a</span>      <span class="number">0x00000014</span>      <span class="number">0x0000001e</span>      <span class="number">0x00000028</span></span><br><span class="line"><span class="number">0x7fffffffe340</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe350</span>: <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0xa278ee00</span>      <span class="number">0xb06404f1</span></span><br><span class="line"><span class="number">0x7fffffffe360</span>: <span class="number">0xffffe3a0</span>      <span class="number">0x00007fff</span>      <span class="number">0x00400786</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffffffe370</span>: <span class="number">0xffffe488</span>      <span class="number">0x00007fff</span>      <span class="number">0x00000000</span>      <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0x7fffffffe380</span>: <span class="number">0x0000000a</span>      <span class="number">0x00000014</span>      <span class="number">0x0000001e</span>      <span class="number">0x00000028</span></span><br><span class="line">0x7fffffffe390: 0x00000000      0x00000000      '0x00000000'    0xb06404f1</span><br></pre></td></tr></table></figure></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>　　通过上面这个bug，我过了一遍GCC的缓冲区溢出攻击保护机制，实际也学到了好些新的知识，毕竟这么底层的东西，平时也是比较少会接触到的。这时候也发现GDB在这种场景分析中十分实用。我在学习C++的虚函数原理时，也通过x/32i看到可执行代码部分的实现，收获颇多，多接触这种底层机理的了解也有助于我们更进一步写出好的程序。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>PLAYING WITH CANARIES <a href="https://www.elttam.com.au/blog/playing-with-canaries/" target="_blank" rel="noopener">https://www.elttam.com.au/blog/playing-with-canaries/</a><br>canary analysis <a href="https://hardenedlinux.github.io/2016/11/27/canary.html" target="_blank" rel="noopener">https://hardenedlinux.github.io/2016/11/27/canary.html</a><br>Stack Smashing Protector <a href="https://wiki.osdev.org/Stack_Smashing_Protector" target="_blank" rel="noopener">https://wiki.osdev.org/Stack_Smashing_Protector</a><br>Stack Smashing On A Modern Linux System <a href="https://www.exploit-db.com/papers/24085/" target="_blank" rel="noopener">https://www.exploit-db.com/papers/24085/</a><br>函数调用过程探究 <a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html" target="_blank" rel="noopener">http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html</a><br>fs:0x28介绍 <a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　处理一个开机coredump问题时，发现是一个必现canary问题，即内存越界访问。一般这类问题发生在数组越界访问，不过这次出现的rootcause有所不同，为代码未对齐导致结构体没对齐，继而在数据传输过程中出现访问越界。bug简单，但鉴于canary是一个有趣的设计，犹如人体免疫系统的表层屏障，能有效规避一些bug，因此我便萌生兴趣系统地了解这个机制，相关学习记录成此文。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="canary" scheme="https://donald-zhuang.github.io/tags/canary/"/>
    
      <category term="coredump" scheme="https://donald-zhuang.github.io/tags/coredump/"/>
    
      <category term="__stack_chk_fail" scheme="https://donald-zhuang.github.io/tags/stack-chk-fail/"/>
    
  </entry>
  
  <entry>
    <title>春秋</title>
    <link href="https://donald-zhuang.github.io/2018/07/08/ChunQiu/"/>
    <id>https://donald-zhuang.github.io/2018/07/08/ChunQiu/</id>
    <published>2018-07-09T02:19:48.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文源自我发在知乎上的一篇回答，16年年初，LP推荐我春秋这首歌，自此开始喜欢张敬轩，也开始入坑林夕。春秋是我最喜欢的一首歌，对其“备胎词”之说的不认同最终推动我写下了知乎的回答（ <a href="https://www.zhihu.com/question/29927847/answer/87183394" target="_blank" rel="noopener">張敬軒的《春秋》歌詞講的是什麼呢？</a> ）。<br>　　截止目前，这首歌不同版本我听了快四千遍，余音绕梁，便对原答案稍加修整，作成此文。同时，私以为好歌手的歌喉是这世间最独一无二的乐器，而轩在这首体现得很好。<br><a id="more"></a><br>　　在我看来，一首好歌得以扣人心弦，有三个不可或缺的因素：动人的旋律、能引起共鸣的歌词、演绎者恰到好处的感情投入。<br>　　春秋曲出Edmond Tsang，有古典乐的味道，节拍密集流畅，曲调循序渐进，华丽动人，每每品味都有不同的感觉。在其诸多版本中，港乐版最为大气磅礴，结尾的弦乐也画龙点睛，回味无穷，如网友评论，“情歌唱出史诗的感觉”。同时，轩对这首歌的演绎也无可挑剔——感情到位，唱功完美，两者也相结合得很好，有网友评港乐版live“惨得荡气回肠”，实至名归。<br>　　曲子引人，词则留人。春秋词很开放，也很流畅，感性与理性的纠缠，本心和超脱的挣扎，深深的悲伤和最后的开悟，其开放让不同人得以听出不同感觉，对其拥有不同的见解，而我自然也有所偏好。<br>　　不少人将这首词等同钟无艳、七友，我则不敢苟同，因为倘若如此，词中便有相当多反讽，一个“失意”不愿“制造恨意”的人不应如此。再看钟无艳、七友两首，夕爷也无反讽的格调，其风格更多是一种自卑，卑微如尘土。因此，这首当是“得不到”的老生常谈，并在悲痛中自我开导。<br>　　如下便是是不才对词的见解，</p><blockquote><p>那夜谁将酒喝掉 因此我讲得多了<br>然后你摇着我手拒绝我　动人像友情深了<br>我没权终止见面　只因你友善依然<br>仍用接近甜蜜那种字眼通电<br>没人应该　怨地怨天<br>得到这结局　难道怪罪神没有更伪善的祝福</p></blockquote><p>　　那天，我借酒意表达爱意，无奈她仅当自己是蓝颜，我们之间的关系只有友情而非爱情，她也因此不希望拒绝伤到我而“友善依然”。拒绝了却“仍用接近甜蜜那种字眼通电”，很多人备胎之说也源于此。拒绝了，为何还友善依旧、为何还甜蜜通电？其实“甜蜜”只是爱恋让自己捕风捉影假想她对自己不同寻常的好，自己其实也很清楚，所以才是“接近甜蜜”。<br>　　我喜欢你，你对我无意，可我还和你做着朋友，总让我觉得还有一丝机会。理性的自己清楚不可能，而且这也许已是最好的结果了，多少人在表白后连朋友都做不成，而今我们两个人之间还有友谊不是很好吗？所以“伪善的祝福”不是反语，只是一种心酸的抱怨。难道我能“怪罪”上天给我这种“祝福”是“伪善”的吗？不能，“没人应该怨天怨地，得到这种结局”。</p><blockquote><p>我没有为你伤春悲秋不配有憾事<br>你没有共我踏过万里不够剧情延续故事</p></blockquote><p>　　悲伤过后，思绪回到当下。当喜欢上一个人时，伊人一颦一笑，内心便掀起阵阵波澜。“天下何人限，慊慊只为汝”，心里只装着一个你，在美好时刻想你，在难过时念你，当你不开心时，辗转反侧，多么希望承受这一切的是自己。你的一切不就是我的春秋大事吗？<br>　　只不过这一幕幕都是独角戏，我的“伤春悲秋”，更多是自己内心的纠缠和幻想，自认爱得轰轰烈烈，在别人眼里，这种爱却未免太“幼稚”。我未曾为你真正付出恋人般的付出，也没与你真正共同经历过风雨飘摇，在你那里也许我连你日记的一句都未曾出现。</p><blockquote><p>头发未染霜　着凉亦错在我幼稚　应快活像个天使<br>有没有运气再扮弱者　玩失意<br>有没有道理为你落发必须得到世人同意<br>心灰得极可耻　心伤得无新意<br>那一线眼泪　欠大志</p></blockquote><p>　　于是开始慰藉自己，我未曾为你而爱得头生华发，在被你拒绝后，我也多么想像以前“弱者”、“失意”时有你的关心和陪伴。此时的我也悲伤绝望到连落发出世的心思都有了。这种悲伤却又依旧是自顾自，大丈夫为情所困，心伤至此，这种“心灰得极可耻，心伤得无新意”，多幼稚。深深自嘲，这眼泪也掉得太过无志。</p><blockquote><p>爱若能堪称伟大　再难挨照样开怀<br>如令你发现为你而活到失败<br>令人不安　我品性坏</p></blockquote><p>　　我也突然明白，真正的爱，再难捱也应该在爱人面前表现得坦然轻松，而不让她担心。如果让你发现我对你的爱如此悲哀堕落，让你不安，是我品性太坏了。此刻我也醒悟到，这种痛苦只是自己内心的折磨，反问自己，“若（你）自觉（自以为）这叫痛苦，未免过分容易”，实际上“应快活像个天使”。</p><blockquote><p>我没有被你改写一生怎配有心事<br>我没有被你害过恨过写成情史　变废纸<br>春秋只转载要事　如果爱你欠意义<br>这眼泪　无从安置</p></blockquote><p>　　开导自己，我没有爱你爱到为你做出“改写一生”的事，也没能在你心中留下一段刻骨铭心的回忆，哪配有心事，也未曾“被你害过恨过”写进你的“春秋”，变成一段被你痛弃的记忆。“春秋只转载要事”，而我对你的爱恋缺了那么多经历和意义，这心事（眼泪）无从安置。</p><blockquote><p>我没有运气放大自私的失意<br>更没有道理在这日你得到真爱制造恨意<br>想心酸　还可以　想心底　留根刺<br>至少要见面上万次</p></blockquote><p>　　“我没有运气放大自私的失意”，将自己的失意放大到惊天动地（内心确实惊天动地，也许天翻地覆不为过），也不该在你得到真爱的今天心生恨意，“想心酸，还可以，想心底留根刺，至少要见面上万次”，这一句应是全句的点睛之笔，总结了男主的觉悟，我心酸，是因为此时爱的人有了自己的Mr. Right，而那个人不是我。但我也没跟她一起经历刻骨铭心的爱情，所以我对她的爱却也无法在心中留下一根“刺”。这“刺”应是什么感觉呢？也许可以用婚纱背后里女主那种心态来描述。也许经历了无数的聚散离合，才能算得上真的刻骨铭心的爱情。<br>　　借用尘埃落定歌词，这首说的就是“无爱可失 得不到相恋别说失恋”。这词里很多只是为了押韵而加，林夕曾说过，他还是会先考虑押韵的要求，所以我觉得词句词义也没必要一一深究。<br>　　这首词的确很惨，感性的悲伤用理性去疗伤，就像往伤口上涂双氧水、涂酒精的感觉，不过夕爷开这一方解药，虽痛却也是有效。<br>　　在这里也希望那些还在悲伤的人们一句，如果你痛苦，请相信，未来会有一个人能够治愈你的痛苦。如果你觉得此生无法恋上第二个人，也许只是悲伤遮住了你的眼，挣开双眼吧，因为会有那么一个人让你再相信爱情的。</p><p>再借用张爱玲《半生缘》收尾</p><blockquote><p>“我要你知道，在这个世界上，总有一个人是会永远等着你的。无论什么时候，无论在什么地方，总会有这么一个人。”</p></blockquote><p>PS:同风格的还有一首尘埃落定，妥妥春秋终章，有兴趣可以听下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文源自我发在知乎上的一篇回答，16年年初，LP推荐我春秋这首歌，自此开始喜欢张敬轩，也开始入坑林夕。春秋是我最喜欢的一首歌，对其“备胎词”之说的不认同最终推动我写下了知乎的回答（ &lt;a href=&quot;https://www.zhihu.com/question/29927847/answer/87183394&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;張敬軒的《春秋》歌詞講的是什麼呢？&lt;/a&gt; ）。&lt;br&gt;　　截止目前，这首歌不同版本我听了快四千遍，余音绕梁，便对原答案稍加修整，作成此文。同时，私以为好歌手的歌喉是这世间最独一无二的乐器，而轩在这首体现得很好。&lt;br&gt;
    
    </summary>
    
      <category term="所思" scheme="https://donald-zhuang.github.io/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="所思" scheme="https://donald-zhuang.github.io/tags/%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>满师 - 香港理工大学毕业设计展</title>
    <link href="https://donald-zhuang.github.io/2018/06/23/From-The-Den/"/>
    <id>https://donald-zhuang.github.io/2018/06/23/From-The-Den/</id>
    <published>2018-06-23T15:20:16.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<img src="/2018/06/23/From-The-Den/vi.jpg" title="PolyU Design Annual Show 2018"></p><p>　　周六和boss双人游HK，主要是去吃和逛，吃了兰芳园、麦奀云吞面、佳佳甜品、妈咪鸡蛋仔等等。讲真，云吞面和丝袜奶茶一直是必吃的，加上都是老店，所以感觉不差。佳佳甜品则是杨枝甘露卖完，然后我跳过芝麻糊和杏仁露点了木瓜炖银耳，真心鄙视下自己，只能下次再补回来了。<br>　　除了吃的，就是逛。逛中大和理大，其中最大的收获是理大的满师毕业展。不得不说，这次年展的内容和质量不错，不少设计关心环境保护、可持续、老龄化等社会问题，相信内地也将需要面对和克服这些问题。<br>　　我个人感兴趣的方向是交互设计、产品设计、环境和室内设计以及相关科技类作品，因此脑袋装的基本是这些。其实，在其他专题也有不少亮点，比如多媒体设计部分，我看了两部片，同时pick 失物认领处的创意。<br>　　不过，隔了一个星期，现在写起上周的展览观感也不是很顺，哈哈，今日事今日毕是有道理的。<br><a id="more"></a></p><hr><p>　　香港理工大学这次毕设年展主题是满师，VI是一个狮头，实物在一楼展厅入口处摆放着。其理念在官方的宣传上如下：</p><blockquote><p>学满出师，乃学途上的一大里程碑。今届年展以[满师]为主题，标志着设计学生修毕课程，正式踏入社会的新一页；<br>好比幼狮离巢，怀着雄心等待机会一鸣惊人。理大设计就如狮子巢穴，为培育设计师提供上佳环境。<br>[师]与[狮]谐音，年展采用本地精心制作的南狮狮头做主视觉，配合其巧妙细节塑造了一套形象系统，代表各个设计科目。<br>传统南狮亦寓意[伊始的好运]，在此祝各毕业生事业一帆风顺。<br>设计：黄雋溢</p></blockquote><p>　　展览的分区情况如下，具体可参见<a href="https://www.polyudesignshow.com/floorplans/" target="_blank" rel="noopener">PolyU Design Show官网</a>介绍。</p><img src="/2018/06/23/From-The-Den/guide.jpg" title="Guide Map For PolyU Design Annual Show 2018"><p>　　每层都有亮点和吸引人的地方，有一些课题也挺引人深思，比如强生(Johnson &amp; Johnson）对于动物试验的讨论，<strong>Let’s Be Honst - We have to do it even it hurts</strong>。其蓝底白字、简约风的海报设计是一个亮点。蓝白色的采用冷静人的身心，使设计整体柔和；字体中多种动物的嵌入贴合主题且友善化；大字体吸引注意力，下方细文阐述观点，引发思考。我挺喜欢这个展位设计，对其阐述的观点我也表示支持。</p><img src="/2018/06/23/From-The-Den/Let%27sBeHonst.jpg" title="Exhibition of job Let" alt="s be honst"><p>　　之后兼具断舍离、可持续、共享资源观念于一身的House Clipper是全场我觉得比较好玩的一个设计，之所以觉得好玩，是因为这玩意我也想过要怎么设计。相关介绍和实现如下，</p><img src="/2018/06/23/From-The-Den/HouseCllipper.jpg" title="The Poster of HouseClipper"><img src="/2018/06/23/From-The-Den/HouseCllipperObject.jpg" title="The User Journey of HouseClipper"><img src="/2018/06/23/From-The-Den/HouseCllipperObject2.jpg" title="The Real Object of House Clipper"><p>　　我们可以看第三图的实物设计，其显示部分采用带触摸功能LCD，并嵌入到抽屉上；传感器座子则内贴于抽屉壁，监控抽屉使用情况以及充当手机座子，便于存放物品时手机录入物件信息。从个人角度来说，我更愿意采用磁贴结构、带触摸面板E-Ink屏，这样便于拆装和再利用，同时降低能耗，而传感器座做手机座的功能略显鸡肋，不如换成如下，</p><blockquote><p>A. 功能加强，电子标签充电座；加WIFI通讯功能用于联网功能，减小电子标签的通讯能耗。(ESP8266)<br>B. 功能精简，只做抽屉使用情况监督功能，缩减体积。(APDS-9930)<br>C. 功能整合，其功能通过电子标签的姿态传感器来做。(MPU6050)</p></blockquote><p>　　不过，实物设计只是一个其很小的部分，我们通过Poster和User Journey可以看到App实现和功能构想。平台的wishlist和communication实现资源交换、社交；在一方面，personalized tips和Second Hand &amp; Donation实现资源的再利用。总的来说，整个设计贴合断舍离、共享和可持续的理念，是一个有趣的设计。<br>　　不过也有这玩意如果真要推广，还是有很多实际性问题需要克服。比如，设计的便利化、起始用户定位、personalized tips和second hand &amp; donation功能的实现，这些目前都只是一种假想，实作并不容易。<br>　　众所周知，香港的城市规划是非常优秀的（<a href="http://daily.zhihu.com/story/9464061" target="_blank" rel="noopener">为什么说香港是我见过最棒的城市规划？</a>），比如旺角一带，看地图会觉得有种规整的美感，基本上地图定位目的地方位和所在街道，就可以关掉地图，照着方向找到。同时在不少地方的绿化也做得非常不错，私以为香港非常有限的土地资源造就了这种相对优美的城市规划。这种环境下，毕业设计中也就会有不少这类好玩的作品，如下面这个Linger POP设计，采用平面化、具备自动复原能力的机械结构来设计公交候车座椅，提升候车体验。考虑到产品特点和维修便利，作者也采用了模块化设计理念。结合香港的现状，这个设计也有效的解决空间不足的问题。</p><img src="/2018/06/23/From-The-Den/LingerPop.jpg" title="The Poster of Design Linger Pop"><p>　　同样，下面这个Connected Chair的设计也非常有创意和设计感，其灵活的使用方式、环境友好、人文化设计，妥妥让老夫想为其点赞。设计者应该是一个萌妹子，而且还是单身的，你们很好奇我为什么知道吧？？因为她的note上面有人评论，“有咁好嘅设计思路，揾男朋友有望啦”，哈哈哈。</p><img src="/2018/06/23/From-The-Den/ConnectedChair.jpg" title="The Poster of Connected Chair"><p>　　产品设计展区中，这套名为Heriture的家具设计挺吸引我的。该设计旨在唤醒人们对过度生产、对过度消费主义(fast-consumerism)和物质主义(materialism)的警惕，借助参数化系统（parametric system）和3D打印技术为人们提供一种对旧家具修缮和复原的途径，也期望以此让更多人选择修缮和重复利用旧家具，而不是直接换新的。<br>　　下图家具上的浅绿色模块就是通过3D打印制作，旧家具通过这些模块实现重新组合、修复和再利用。这个设计的理念挺贴合我对大部分<strong>坏了的东西能修就修，当确实无法修复时才丢弃</strong>的观点，加上其具有一定的Geek风格，所以很喜欢。</p><img src="/2018/06/23/From-The-Den/Heriture-2.jpg" title="The exhibition of Heriture"><p>　　除此之外，还有一个对快递包装问题关注的设计（<a href="http://www.ebrun.com/20171211/258466.shtml" target="_blank" rel="noopener">谁将引领快递包装革命</a>）。我对这个话题感兴，一方面毕竟自己学过一点包装设计，另一方面，这个设计所尝试克服的问题确实有一定的社会价值。<br>　　不过我觉得，比快递包装更值得研究改进的就是<strong>外卖包装</strong>，这个需求量也是妥妥的。实际在一楼展厅就有一个pizza盒子设计，环境友好也很有趣。具体我就不做多介绍，大伙可以看图。</p><img src="/2018/06/23/From-The-Den/ReuseablePackaging.jpg" title="Reusable Vaccum Delivery Packaging"><img src="/2018/06/23/From-The-Den/PizzaPackaging.jpg" title="The World Make Happier By Pizza"><p>　　然后我还被一款舟的“海报”收割了，产品本身是凳子之类的用途，在洪水期间可以调整为简单的舟，用于逃生。作者已经做出产品了，不过根据演示视频来看，这玩意经不起大风浪，但看起来还是挺好玩的。</p><img src="/2018/06/23/From-The-Den/Boat.jpg" title="Affordable Life-saving Furniture for Flooding"><p>　　工作原因，我一直在思考<strong>TV未来的变革方向</strong>。我当前的想法是，<strong>TV未来是一个交互界面</strong>，可以是智能家居等的交互入口。而这次年展中，有一款名为融合（Homeny）的交互设计就是通过TV做的，其面向的是失智症这一社会问题。主体通过家具采集失智老人家居信息，整合后通过APP提供给家属了解老人的活动情况，并可客制化相关的TIPS信息，通过TV应用提示老人，实现一个24小时对失智老人的监护。同时也提供一系列温馨应用（warming reminders），如family photos功能，期望以此缓解老人脑退化。具体相关信息实现可以参考下面的海报信息。</p><img src="/2018/06/23/From-The-Den/Homeny.jpg" title="Homeny"><p>　　这次展览最可惜的应该是没有看到10楼环境和室内设计学的作品，我们上去的时候已经关了，这个是我非常感兴趣的。我也相信在香港这种环境下，其环境和室内设计也会有不少亮点，明年吧，我会再来，哈哈。<br>　　最后，送一张海报给我自己，这个也是毕设作品之一。哈哈，我们在去香港理工之前，就去了海港城的诚品书店，逼格很高的一个书店。</p><img src="/2018/06/23/From-The-Den/zhuangbi.jpg" title="The Poster for the eslite bookstore">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;img src=&quot;/2018/06/23/From-The-Den/vi.jpg&quot; title=&quot;PolyU Design Annual Show 2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　周六和boss双人游HK，主要是去吃和逛，吃了兰芳园、麦奀云吞面、佳佳甜品、妈咪鸡蛋仔等等。讲真，云吞面和丝袜奶茶一直是必吃的，加上都是老店，所以感觉不差。佳佳甜品则是杨枝甘露卖完，然后我跳过芝麻糊和杏仁露点了木瓜炖银耳，真心鄙视下自己，只能下次再补回来了。&lt;br&gt;　　除了吃的，就是逛。逛中大和理大，其中最大的收获是理大的满师毕业展。不得不说，这次年展的内容和质量不错，不少设计关心环境保护、可持续、老龄化等社会问题，相信内地也将需要面对和克服这些问题。&lt;br&gt;　　我个人感兴趣的方向是交互设计、产品设计、环境和室内设计以及相关科技类作品，因此脑袋装的基本是这些。其实，在其他专题也有不少亮点，比如多媒体设计部分，我看了两部片，同时pick 失物认领处的创意。&lt;br&gt;　　不过，隔了一个星期，现在写起上周的展览观感也不是很顺，哈哈，今日事今日毕是有道理的。&lt;br&gt;
    
    </summary>
    
      <category term="游" scheme="https://donald-zhuang.github.io/categories/%E6%B8%B8/"/>
    
    
      <category term="展览" scheme="https://donald-zhuang.github.io/tags/%E5%B1%95%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Debug 杂谈</title>
    <link href="https://donald-zhuang.github.io/2018/05/02/DebugTips/"/>
    <id>https://donald-zhuang.github.io/2018/05/02/DebugTips/</id>
    <published>2018-05-02T19:42:03.000Z</published>
    <updated>2018-11-11T02:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Debug是我们工作中的核心技能之一，而常年面对系统中各种问题，如果不加系统化，处理完问题遗留下的就难以形成经验，最后碎片化并，难以积累。有这种觉悟也让我开始思考应该怎么去积累，怎么去不断突破瓶颈，上升到另一个阶段。<br><a id="more"></a></p><hr><p>　　前阵子遇到一个问题，我处理了一个星期没进度，最后是cdrink接手一天不到就解决，那会我看他的mantis解释这是一个vtable链接错误导致的异常。前阵子看完程序员自我修养，也才明白这是一个全局符号介入问题[1]。两个不同的动态库具备同样的symbol，导致加载动态库时符号冲突，进程调用到错误的动态库，而修正方式是给一方加上namespace，编译时经过C++的符号修饰机制就能避开这个问题。<br>　　国庆前，我接手了新项目中间件glibc切bionic的工作。第一次给中间件切换Toolchain，因此收获挺多的。一直以来，我都坚信代码是最理性和真实的，任何问题想不通的时候，就应该Reading The Fucking Source Code and Just Fucking Google It，特别是这种通用的技术，所以看了一些文章和部分ld的code，对链接、装载和库产生兴趣，也就开始看《修养》。想来看完《修养》也串起了这次切换遇到的诸多问题。<br>　　除去为了处理一些np类函数专门做的syscall实现和其他portable处理，印象中比较好玩的一个问题是客户回报说编译过，但系统起不来的bug。分析log，异常原因为64bit linker加载32bit xxx.so导致，linker相关代码如下，但实际客户用的是32bit的bin档，而不是64bit的，同时对应的so路径是原先glibc加载库，而不是新的加载库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ElfReader::VerifyElfHeader() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header_.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>) &#123;</span><br><span class="line">    DL_ERR(<span class="string">"\"%s\" has bad ELF magic: %02x%02x%02x%02x"</span>, name_.c_str(),</span><br><span class="line">           header_.e_ident[<span class="number">0</span>], header_.e_ident[<span class="number">1</span>], header_.e_ident[<span class="number">2</span>], header_.e_ident[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to give a clear diagnostic for ELF class mismatches, since they're</span></span><br><span class="line">  <span class="comment">// an easy mistake to make during the 32-bit/64-bit transition period.</span></span><br><span class="line">  <span class="keyword">int</span> elf_class = header_.e_ident[EI_CLASS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS64) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS32) &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" is 32-bit instead of 64-bit"</span>, name_.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" has unknown ELF class: %d"</span>, name_.c_str(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS32) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS64) &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" is 64-bit instead of 32-bit"</span>, name_.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DL_ERR(<span class="string">"\"%s\" has unknown ELF class: %d"</span>, name_.c_str(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>　　就在我纠结的时候，看到还有一个报错，”Warning: yyy.so unused DT entry: %s (type 0xf arg %p) (ignoring)”，这个问题是因为Android Linker解析ELF的.dynamic section时，不支持DT_RPATH这个D_TAG类型导致，这个tag type指定执行档所依赖动态库的搜索路径。在安卓环境中，通过LD_LIBRARY_PATH来指定。就在那时候我突然想起上面的异常就是指定错误的so检索路径导致，如此看来应该在/system/lib64下有同名的xxx.so，ls了下，果真如此。而客户的进程是通过init.rc起的服务，那么对应的LD_LIBRARY_PATH就是开机起服务设置，查init.rc的参数设置，指定为异常的路径，请客户修正路径后，问题解决。而通过上面这个也可知道编译bionic库时，应该加上–disable-rpath的编译选项来关闭生产DT_RPTAH，如果安卓支持这个TAG，而我们切换编译toolchain之后，没及时更新编译选项，这个问题也会很难处理。<br>　　切换过程中也伴随着一些code的refine和实现，对于这两个，我一直践行一个观点，逻辑的东西应该往上移植，而不应该由底层承担，底层应该尽量ATOM化，底层的逻辑越多，也就会导致稳定性变差和难以维护。作为关键部件，应该尽量轻便不应该复杂化。就这点我可以举出几个例子来说明。<br>　　这阵子处理一个HDMI问题，一台设备输出有声 4K pattern，正常情况下是能够正常播放的，STR待机后唤醒，出现有图无声的问题，但HDCP校验是通过的，这个现象就很奇怪，随后我们通过数字逻辑分析仪看到，两个异常点，一是待机</p><blockquote><p>[2]The Android linker (/system/bin/linker) does not support RPATH or RUNPATH, so we set LD_LIBRARY_PATH=$USR/lib and try to avoid building useless rpath entries with –disable-rpath configure flags. Another option to avoid depending on LD_LIBRARY_PATH would be supplying a custom linker - this is not done due to the overhead of maintaining a custom linker.<br>　　<br>[1] P218 程序员的自我修养<br>[2] <a href="https://stackoverflow.com/questions/33206409/unused-dt-entry-type-0x1d-arg" target="_blank" rel="noopener">https://stackoverflow.com/questions/33206409/unused-dt-entry-type-0x1d-arg</a><br><a href="https://7chan.org/pr/src/debugging_-_the_9_indispensable_rules_for_finding_.pdf" target="_blank" rel="noopener">https://7chan.org/pr/src/debugging_-_the_9_indispensable_rules_for_finding_.pdf</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Debug是我们工作中的核心技能之一，而常年面对系统中各种问题，如果不加系统化，处理完问题遗留下的就难以形成经验，最后碎片化并，难以积累。有这种觉悟也让我开始思考应该怎么去积累，怎么去不断突破瓶颈，上升到另一个阶段。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="DEBUG" scheme="https://donald-zhuang.github.io/tags/DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>Debug Checklist</title>
    <link href="https://donald-zhuang.github.io/2018/05/02/Debug%20CheckList/"/>
    <id>https://donald-zhuang.github.io/2018/05/02/Debug CheckList/</id>
    <published>2018-05-02T19:42:03.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　经常和各种bug打交道，处理多了，也就会发现有些流程在处理不同问题都会用到，套路是也。</p><p>　　鉴于很多流程早期容易被忽略，后续debug需重新沟通了解，造成不必要的麻烦。也因此，我有想法将这些流程整理汇总，后续debug做checklist用，同时记录下来也能不断完善改进。</p><p>　　这篇目前只是搭个架子，还会不完善改进。<br><a id="more"></a></p><hr><h2 id="1-常规信息收集"><a href="#1-常规信息收集" class="headerlink" title="1. 常规信息收集"></a>1. 常规信息收集</h2><p>　　常规信息收集主要是明确异常是问题还是feature，还是环境或用户操作异常，比如可能问题在新版本上解决了，但测试人员在旧版本上测试导致未修正。另外，低概率和远程协助debug时，现场技术型FAE可能会同时对接客户和RD，在对接RD时会有大量信息被作为常识隐含于沟通中，而这种隐含信息在对接客户时，也可能会被作为常识隐含跳过，这也就会导致一些重要的操作差异或者信息被忽略，导致一些奇怪的问题现象出现。而这往往需要耗费大量时间排查。我们沟通的首要目标就是要明确前置这些隐含信息是否为真，同时明确正确的复现条件和步骤。</p><p>　　当确认是一个问题时，信息收集可以了解问题复现难度、初步判定问题范围、是否新旧版本有差等，为问题处理提供早期思路。在有问题现场的时候，信息问询也能避免为盲目保护现场影响测试进度或其他问题处理开展。在人力紧张的时候，能对这个问题进行预判，排处理优先级。</p><p>　　就常见问题而言，主要需要收集的信息有如下，这些在做bug report时就需要详细说明，是研发人员debug的根本，也能减少和测试人员的沟通次数，提升工作效率。</p><blockquote><ol start="0"><li>硬件平台、软件版本、对接人，问题预期响应和实际状态，问题复现步骤、操作手法、复现概率、还原手段</li><li>问题现场是否还有保留，初步判定问题是哪个模块的 &gt;&gt; <code>是否需要请模块owner一起debug</code></li><li>同操作对比机好坏情况，尝试复现bug，确保它确实是个bug，而不是用户或环境的error。 </li><li>该问题是否有已修过的类似异常，可以跨软件硬件平台了解，看是否有思路可以参考。</li><li>同型号机器是否有好坏版本 &gt;&gt; <code>排查为新改出来的问题，也可定位可能的修改</code></li><li>异常的log是否有收集</li></ol></blockquote><h2 id="2-问题debug"><a href="#2-问题debug" class="headerlink" title="2. 问题debug"></a>2. 问题debug</h2><p>　　面对一个BUG，无论是否解过类似问题，我们都会有一些疑问或者假设，而这些就是我们debug首先需要厘清的和确认的。这些假设中，会有不少是我们以为一定会正确，但未经验证的，比如没有跑过测试或只在特定场景做过测试，并未在当前场景测试过的。这些想当然往往也是问题常出现的地方，因此需要我们实验验证。</p><p>　　Debug期间，我们要根据假设和疑点不断做实验，实验后会出现新的结论、疑问和一些冲突点，而冲突点往往指引异常的根源所在。有些时候冲突点并未能直接指引问题根源，但却可以从反面推断最初的假设和认知正确与否，是否需要重新定位问题，更换方向下手。</p><p>　　以本地多媒体视频播放卡顿来说，常见的debug方向无非MEMC处理、BW不足、CPU loading过重三种，这三者debug方式不尽相同，处理方式也有所差异，因此我们初步定位的方向不同，debug方式便会有所差，怀疑的点便也不同，需要关注的点也就天差地别，但当实验和假设冲突时，那就需要我们根据当下已有信息做方向转换。</p><blockquote><ol start="0"><li>是否有coredump文件，能否通过coredump文件回溯异常flow和问题点。log上有哪些异常，是否可以google下？</li><li>根据已有的信息，我们能过推断出问题出现在哪个模块，大概可能在哪些接口或流程上有问题。</li><li>目前疑问是什么，假设有哪些，根据此构建实验验证</li><li>加打印或者单元测试，定位异常位置，是输入 &gt; 处理 &gt; 输出</li><li>记录实验结论和现象，是否发现异常原因或出现新的疑点</li><li>重复3和4，如果未能找到原因，重新定位问题，确定是否需要更换方向。</li></ol></blockquote><p>　　复现规律问题。</p><blockquote><ol><li>必现或高概率问题，根据现象分析产生问题原因，查模块</li><li>低概率问题尽量多测试，找复现规律转化为必现问题以便分析</li></ol></blockquote><h2 id="3-Rootcause确认和分析汇总"><a href="#3-Rootcause确认和分析汇总" class="headerlink" title="3. Rootcause确认和分析汇总"></a>3. Rootcause确认和分析汇总</h2><p>　　在debug出问题rootcause或者有临时措施时，需要对问题debug过程进行梳理，并整理问题的异常原因。这个过程主要目前是明确结论是否正确，问题是否解决到位，是否有其他潜在风险，同时也能存档相关处理过程，当再次遇到类似问题时，能提供这部分信息出来供借鉴和review，这对debug人也是一种复盘和提升。</p><blockquote><ol><li>rootcause是什么？解决措施是什么？</li><li>解决措施是否彻底解决问题还是在客户需求内解决？是否有side effect？</li><li>测试建议，是否需要完整测试？单元测试？关联模块测试？场景测试？</li></ol></blockquote><h2 id="4-常见DEBUG工具和措施"><a href="#4-常见DEBUG工具和措施" class="headerlink" title="4. 常见DEBUG工具和措施"></a>4. 常见DEBUG工具和措施</h2><h4 id="print大法"><a href="#print大法" class="headerlink" title="print大法"></a>print大法</h4><p>#### </p><h2 id="4-Code-Review检查"><a href="#4-Code-Review检查" class="headerlink" title="4. Code Review检查"></a>4. Code Review检查</h2><p>　　针对Rootcause做的fix，需要做专门的review，一方面避免fixer考虑不周和参吃不齐的上code质量，一方面方便后续问题追踪，code reviewer能在其他member遇到类似问题时，提供建议和思路。</p><p>　　在做code review之前，fixer需要做如下工作确认修改，并将相应信息提供给reviewer做参考。</p><blockquote><ol><li>有无本地编译过</li><li>有无做功能确认</li><li>有无side effect，可能会打到哪些模块，是否验证过</li><li>有无做功能开关，是否需要用项目宏隔开</li><li>有无多余的log需要拿掉</li><li>有无跨环境的lib需要确认，比如bionic和glibc是否都可编译通过并正常工作。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　经常和各种bug打交道，处理多了，也就会发现有些流程在处理不同问题都会用到，套路是也。&lt;/p&gt;
&lt;p&gt;　　鉴于很多流程早期容易被忽略，后续debug需重新沟通了解，造成不必要的麻烦。也因此，我有想法将这些流程整理汇总，后续debug做checklist用，同时记录下来也能不断完善改进。&lt;/p&gt;
&lt;p&gt;　　这篇目前只是搭个架子，还会不完善改进。&lt;br&gt;
    
    </summary>
    
      <category term="技术整理" scheme="https://donald-zhuang.github.io/categories/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/"/>
    
    
      <category term="DEBUG" scheme="https://donald-zhuang.github.io/tags/DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>TinyHttpd源码解析</title>
    <link href="https://donald-zhuang.github.io/2017/07/24/TinyHttpd%20Analysis/"/>
    <id>https://donald-zhuang.github.io/2017/07/24/TinyHttpd Analysis/</id>
    <published>2017-07-24T22:57:45.000Z</published>
    <updated>2018-11-10T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本图解HTTP。<br>这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。<br>书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了TinyHttpd的source code来了解http协议的实现和实际工作场景。<br><a id="more"></a></p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本<a href="https://book.douban.com/subject/25863515" target="_blank" rel="noopener">图解HTTP</a>。这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>的source code来了解http协议的实现和实际工作场景。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><p>声明：这篇里面的代码并不是<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>的源码，是我自己手动临摹一遍的代码，实测跑通了。一直相信代码自己码一遍会比纯看加注释收获多一些。同时，<a href="http://sourceforge.net/projects/tinyhttpd/" target="_blank" rel="noopener">TinyHttpd</a>只有几百行，自己码一遍也不算什么。关于阅读tinyhttpd的source code，个人觉得可以以如下顺序展开：main –&gt; startup –&gt; accept_request –&gt; execute_cgi –&gt;了解cgi实现，因此本文就按照此顺序展开分享。</p><h4 id="主体框架-gt-main"><a href="#主体框架-gt-main" class="headerlink" title="主体框架 -&gt; main()"></a>主体框架 -&gt; main()</h4><p>main函数是整个httpd的工作框架，具体的实现流程如下， startup创建socket通信并建立端口监听 –&gt; accept等待客户端连接请求 –&gt; accept_request处理客户端http请求 –&gt; cleanup释放资源<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sever_sock = <span class="number">-1</span>;</span><br><span class="line">    u_short port = <span class="number">5277</span>;</span><br><span class="line">    <span class="keyword">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line">    <span class="keyword">pthread_t</span> newthread;</span><br><span class="line"> </span><br><span class="line">    sever_sock = startup(&amp;port); <span class="comment">//建立socket通讯，并进行端口监听</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd running on port %d\n"</span>, port);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       client_sock = accept(sever_sock,</span><br><span class="line">                            (struct sockaddr *)&amp;client_name,</span><br><span class="line">                            &amp;client_name_len); <span class="comment">// 接受客户端请求</span></span><br><span class="line">       <span class="keyword">if</span>(client_sock == <span class="number">-1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           error_die(<span class="string">"accept failed"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(pthread_create(&amp;newthread, <span class="literal">NULL</span>, accept_request, (<span class="keyword">void</span> *)&amp;client_sock) != <span class="number">0</span>) <span class="comment">// 创建子线程处理客户端请求</span></span><br><span class="line">       &#123;</span><br><span class="line">           perror(<span class="string">"pthread_create failed"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cleanup(sever_sock); <span class="comment">// 关闭socket，释放相关资源</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd stopped\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="基础通讯实现-gt-startup"><a href="#基础通讯实现-gt-startup" class="headerlink" title="基础通讯实现 -&gt; startup()"></a>基础通讯实现 -&gt; startup()</h4><p>HTTP是一个应用层协议，通过TCP/IP进行传输的。HTTP协议规定，连接请求从客户端发起，服务端提供资源响应。在客户端无请求的情况下，服务端不会主动发送响应。服务端通讯建立过程： socket创建套接字 –&gt; bind绑定套接字 –&gt; listen监听套接字 –&gt; accept等待客户端连接请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> httpd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建socket描述符：采用TCP通讯方式，在第二个参数确定的情况下，第三个参数可以传0由函数自动匹配对应协议</span></span><br><span class="line">    httpd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>( httpd == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"socket failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定套接字：绑定IP地址和端口号</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port   = htons(*port); <span class="comment">// 指定端口：若端口为0，则自动分配一个端口。将端口转换为网络字节序</span></span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//IP地址：INADDR_ANY -&gt; 服务器上所有的IP对应端口号都监听</span></span><br><span class="line">    <span class="keyword">if</span>( bind(httpd,(<span class="keyword">const</span> struct sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"bind failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 若端口为0，获取自动分配的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(*port == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span>( getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span> ) <span class="comment">// 获取套接字信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            error_die(<span class="string">"getsockname failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *port = ntohs(name.sin_port); <span class="comment">// 获取端口号： 网络字节序转主机字节序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">if</span>( listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span> ) <span class="comment">// 监听httpd，等待客户端连接请求，并设置最大可排队连接数为5个</span></span><br><span class="line">    &#123;</span><br><span class="line">        error_die(<span class="string">"listen failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpd;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 请求处理 -&gt; accept_request() ####</span><br><span class="line">accept_request是这个httpd的主体。通过解析http请求，对应发送资源和响应。http请求报文主要由三部分组成： 报文首部（分请求起始行和可选的请求首部字段）、空行、报文主体。通常并不一定要有报文主体。请求报文中每一行都以回车换行（**CRLF**,即<span class="string">"\r\n"</span>）作为结束标志。</span><br><span class="line">``` html</span><br><span class="line">Method URL HTTP_Version&lt;CRLF&gt;    <span class="comment">// 请求起始行</span></span><br><span class="line">Header_Name: Header_Value&lt;CRLF&gt;  <span class="comment">// 请求首部字段，可选</span></span><br><span class="line">... ...</span><br><span class="line">Header_Name: Header_Value&lt;CRLF&gt;</span><br><span class="line">&lt;CRLF&gt;                           <span class="comment">// 空行，表示报文首部结束</span></span><br><span class="line">BODY                             <span class="comment">// 报文主体</span></span><br></pre></td></tr></table></figure></p><p>下文我们用来分析的报头首部是用wireshark抓chrome访问httpd时发出的，只有报文首部，没有报文主体。不同浏览器可能有所差异，具体可用wireshark尝试分析。<br>TinyHttpd主要是针对请求起始行进行处理。请求起始行由Method、Request-Url和Http版本信息组成，三者通过空格隔开。如下请求起始行中”GET”就是method，表示请求访问服务器的类型，用于告知服务器访问意图。”/“为URL，表示请求访问的资源，也称作Request-URL，”HTTP/1.1”表示http版本信息，用来提示客户端使用的http协议功能。<br>下面的内容为请求首部字段，是可选的，在accept_request的execute_cgi中，我们只有在处理POST请求时才会去解析这部分的内容，对于GET，我们解析请求起始行后会去清除buf中的这部分数据，避免对后续处理或者下次通讯请求造成影响。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1                // 请求起始行</span><br><span class="line">Host: 192.168.179.145:5277    // 以下为可选首部字段，格式为Header-Name： Header-Value<span class="tag">&lt;<span class="name">CRLF</span>&gt;</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br></pre></td></tr></table></figure></p><p>解析请求的具体实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *pclient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client = *(<span class="keyword">int</span>*)pclient;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> method[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">255</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, cgi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numofchars = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 获取一行请求报文，以LF（\n）作为结尾。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recieve : %s"</span>, numofchars == <span class="number">0</span> ? <span class="string">"NULL\r\n"</span> : buf);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对于http报文来说，第一行即为请求起始行：method url http-version</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[i]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>) <span class="comment">// 获取请求方法</span></span><br><span class="line">        method[j++] = buf[i++];</span><br><span class="line">    method[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// strcasecmp为忽略大小写，比较字符串是否相同，相同则返回0，否则参数1长度大于参数2时返回正值，反之返回负值。</span></span><br><span class="line">    <span class="comment">// TinyHttpd只支持GET和POST两种方法</span></span><br><span class="line">    <span class="keyword">if</span>( strcasecmp(method, <span class="string">"GET"</span>) &amp;&amp; strcasecmp(method, <span class="string">"POST"</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        bad_request(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检测请求是POST还是GET，若为POST则需要CGI处理，置起对应标志</span></span><br><span class="line">    cgi = strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清除多余空格</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[j]) &amp;&amp; (j++ &lt; <span class="keyword">sizeof</span>(buf)) )  </span><br><span class="line">        ;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取URL，用于确定访问什么资源</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isspace</span>((<span class="keyword">int</span>)buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf)) )</span><br><span class="line">    &#123;</span><br><span class="line">        url[i++] = buf[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">'\0'</span>;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Request-URL： %s\r\n"</span>, url);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* process the request */</span></span><br><span class="line">    <span class="keyword">if</span>(cgi == <span class="number">0</span>) <span class="comment">/* method : GET */</span></span><br><span class="line">    &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="comment">// 若GET请求的URL带?,则表明有查询参数，须CGI处理</span></span><br><span class="line">        <span class="keyword">while</span>( (*query_string != <span class="string">'?'</span>) &amp;&amp; (*query_string != <span class="string">'\0'</span>) ) </span><br><span class="line">            query_string++;</span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">'?'</span>) <span class="comment">/* should be process by CGI */</span></span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">            *query_string = <span class="string">'\0'</span>;</span><br><span class="line">            query_string++; <span class="comment">//截取查询的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以上为请求起始行的解析过程。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将URL转化为本地资源路径path</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"htdocs%s"</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果path为目录则返回首页路径</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">"index.html"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"request path: %s\r\n"</span>, path);</span><br><span class="line">#endif</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//检测请求文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(stat(path, &amp;st) == <span class="number">-1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//文件不存在则清除剩余header信息，即可选首部字段部分。</span></span><br><span class="line">        <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf) )</span><br><span class="line">        &#123;</span><br><span class="line">            numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        not_found(client); <span class="comment">// 向浏览器声明没有相应资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若请求URL为路径，则返回首页</span></span><br><span class="line">        <span class="comment">// warning： 这里有一个bug，假设URL为"htdocs/index"，本地存在这个目录，</span></span><br><span class="line">        <span class="comment">// 但不存在"htdocs/index/index.html"这里会合成之后的路径就是错的</span></span><br><span class="line">        <span class="keyword">if</span>( (st.st_mode &amp; S_IFMT) == S_IFDIR )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">"/index.html"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 检测到文件具备可执行权限，当请求文件为可执行程序，则应执行对应程序获取执行结果</span></span><br><span class="line">        <span class="keyword">if</span>( (st.st_mode &amp; S_IXUSR ) ||    <span class="comment">// 文件所有者具备执行权限</span></span><br><span class="line">            (st.st_mode &amp; S_IXGRP ) ||    <span class="comment">// 用户组具备执行权限</span></span><br><span class="line">            (st.st_mode &amp; S_IXOTH ) )     <span class="comment">// 其他用户具备可执行权限</span></span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">#<span class="keyword">if</span> DEBUG_ENABLE</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cgi[%d]: goto %s\r\n"</span>, cgi, cgi == <span class="number">0</span> ? <span class="string">"serve_file"</span>:<span class="string">"execute_cgi"</span>);</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cgi == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            serve_file(client, path); <span class="comment">// 请求文件存在且非执行，则发送文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            execute_cgi(client, path, method, query_string); <span class="comment">// 需执行CGI获取内容的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(client);     <span class="comment">//释放客户端套接字，通讯结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="执行CGI"><a href="#执行CGI" class="headerlink" title="执行CGI"></a>执行CGI</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *query_string )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]= &#123;<span class="string">'A'</span>, <span class="number">0</span>,&#125;;</span><br><span class="line">    <span class="keyword">int</span> cgi_in[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;, cgi_out[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//声明管道通讯，用于父子进程之间的通讯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> content_length = <span class="number">-1</span>, numofchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, status;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是GET方法，则清除剩余http头</span></span><br><span class="line">        <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>,buf) ) <span class="comment">//clean the header</span></span><br><span class="line">        &#123;</span><br><span class="line">            sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(buf, <span class="string">"\n"</span>)) <span class="comment">// 解析终止条件：HTTP请求头部解析完</span></span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="number">14</span>] = <span class="string">'\0'</span>;  <span class="comment">//strlen("content-length") == 14</span></span><br><span class="line">            <span class="comment">// 解析http头请求字段，获取content-length字段值，即实体主体大小</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="number">0</span> == strcasecmp(buf, <span class="string">"content-length"</span>) ) </span><br><span class="line">            &#123;</span><br><span class="line">                content_length = atoi(&amp;buf[<span class="number">16</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            numofchars = sock_getline(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(content_length == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果没有成功解析到，则表明这是一个错误请求</span></span><br><span class="line">            bad_request(client);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 响应报文，返回正确响应码200</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 200 OK\r\n"</span>); <span class="comment">// 响应报文起始行组成： HTTP-Version Status-Code Reason-Phrase</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//pipe操作必须在fork之前，这边子进程才能继承到两组文件描述符，实现父子进程之间的通讯</span></span><br><span class="line">    <span class="keyword">if</span>( (pipe(cgi_out) &lt; <span class="number">0</span>) || (pipe(cgi_in) &lt; <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建管道，fd[0]--&gt;读 fd[1]&lt;--写，创建失败则返回信息给客户端</span></span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( (pid = fork()) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//为方便理解和阅读代码，加的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDIN    (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDOUT   (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STDERR   (2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> meth_env[<span class="number">255</span>], query_env[<span class="number">255</span>], length_env[<span class="number">255</span>];</span><br><span class="line">        dup2(cgi_out[<span class="number">1</span>], DEFINE_STDOUT); <span class="comment">// dup2将系统标准输出定义到cgi_out[1]</span></span><br><span class="line">        close(cgi_out[<span class="number">0</span>]);               <span class="comment">// 关闭cgi_out[0],避免误操作</span></span><br><span class="line">        dup2(cgi_in[<span class="number">0</span>], DEFINE_STDIN);   <span class="comment">// 将系统标准输入定义到cgi[0]上</span></span><br><span class="line">        close(cgi_out[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">"REQUEST_METHOD=%s"</span>, method); <span class="comment">//将请求方法保存在进程所在的环境变量中</span></span><br><span class="line">        putenv(meth_env);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( strcasecmp(method,<span class="string">"GET"</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">"QUERY_STRING=%s"</span>, query_string); <span class="comment">// GET方法需提供查询的信息</span></span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">"CONTENT_LENGTH=%d"</span>, content_length); <span class="comment">// POST方法提供主题的大小</span></span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        execl(path, path, <span class="literal">NULL</span>); <span class="comment">// 执行CGI程序,同时继承了子进程的文件描述符</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 关闭两个不会操作到的pipe，避免误操作</span></span><br><span class="line">        close(cgi_in[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_out[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; content_length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                recv(client, &amp;ch, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// POST方法需要解析报文主体实体，然后发给CGI程序</span></span><br><span class="line">                write(cgi_in[<span class="number">1</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(read(cgi_out[<span class="number">0</span>], &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="comment">// 获取CGI执行结果，并通过Socket返回客户端</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            send(client, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cgi_out[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_in[<span class="number">1</span>]);</span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>); <span class="comment">// 等待所有子进程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件发送实现"><a href="#文件发送实现" class="headerlink" title="文件发送实现"></a>文件发送实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">( <span class="keyword">int</span> client, FILE *resource )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    fgets( buf, <span class="keyword">sizeof</span>(buf), resource );      <span class="comment">// 读取1024bytes数据</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(resource))                    <span class="comment">// 如果文件未EOF则继续读</span></span><br><span class="line">    &#123;</span><br><span class="line">        send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);    <span class="comment">// socket传输数据</span></span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> numofchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="string">'A'</span>, <span class="string">'\0'</span>,&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">    <span class="keyword">while</span>( (numofchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf) )</span><br><span class="line">    &#123;</span><br><span class="line">        numofchars = sock_getline( client, buf, <span class="keyword">sizeof</span>(buf) ); <span class="comment">// 清除请求头。</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    resource = fopen(filename, <span class="string">"r"</span>);    <span class="comment">// 打开文件读取</span></span><br><span class="line">    <span class="keyword">if</span>( resource == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        not_found(client);              <span class="comment">// 资源未找到或无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        headers(client, filename);      <span class="comment">// 发送服务器响应报文首部</span></span><br><span class="line">        cat(client, resource);          <span class="comment">// 发送服务器响应实体主体</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(resource);                   <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关函数实现"><a href="#相关函数实现" class="headerlink" title="相关函数实现"></a>相关函数实现</h4><p>1、获取客户端请求报文的一行内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_getline</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((buf == <span class="literal">NULL</span>) &amp;&amp; (size == <span class="number">0</span>) &amp;&amp; (sock == <span class="number">-1</span>)) <span class="comment">// 参数合法性检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parameter error, please check %s[%d]\n"</span>, __func__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>( (i &lt; size - <span class="number">1</span>) &amp;&amp; (ch != <span class="string">'\n'</span>) ) <span class="comment">// \n是行结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = recv(sock, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n = recv(sock, &amp;ch, <span class="number">1</span>, MSG_PEEK);    <span class="comment">// MSG_PEEK可实现下次读到的，仍是此次读取到的内容</span></span><br><span class="line">                <span class="keyword">if</span>( (n &gt; <span class="number">0</span>) &amp;&amp; (ch == <span class="string">'\n'</span>) )        <span class="comment">// 若读取到的\r\n，则此次读取结束，读取到的字符为\n</span></span><br><span class="line">                &#123;</span><br><span class="line">                    recv(sock, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ch = <span class="string">'\n'</span>;                       <span class="comment">// 否则设定读取的字符为\n，读取结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、服务器响应报文实现<br>为方便代码编写和阅读，我在tinyhttpd的基础上实现了下面这个函数，专门用于发送字符到socket<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_str</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ret = send(client, str, <span class="built_in">strlen</span>(str), <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    ret == <span class="built_in">strlen</span>(str) ?  <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">"send_str error[ret = 0x%02x].\r\n"</span>, ret);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发送文件前的响应头*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">( <span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)filename;</span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);          <span class="comment">// 2**表示执行成功，200表示请求被正常处理</span></span><br><span class="line">    send_str(client, SERVER_STRING);</span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);  <span class="comment">// 发送资源的MIME为text/html，即文本类型</span></span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未找到文件或无法访问文件的响应报文 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 4**的状态码表明错误是客户端引发的</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 404 NOT FOUND\r\n"</span>); <span class="comment">//404表示请求的资源不存在或服务器不提供此资源访问 </span></span><br><span class="line">    send_str(client, SERVER_STRING);</span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;HTML&gt;&lt;TITLE&gt;NOT FOUND&lt;/TITLE&gt;"</span>             <span class="comment">// 发送一个简单页面用于提示</span></span><br><span class="line">                     <span class="string">"&lt;BODY&gt;&lt;P&gt; the sever couldn't fullfill"</span></span><br><span class="line">                     <span class="string">"your request because the resource specified"</span></span><br><span class="line">                     <span class="string">"is unavailable or nonexistence."</span></span><br><span class="line">                     <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 错误请求响应报文*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bad request.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 服务器不支持对应的方法或者报文语法时，会发出错误请求报文</span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 400 BAD REQUEST\r\n"</span>);  <span class="comment">// 400表示请求错误或者请求的报文中存在语法错误</span></span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;P&gt; Your browse sent a bad request,"</span></span><br><span class="line">            <span class="string">"such as a POST without a Content-Length.\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务器内部异常响应报文*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_ENABLE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not execute.\r\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    send_str(client, <span class="string">"HTTP/1.0 500 Internal Server Error\r\n"</span>); <span class="comment">// 5**为服务器错误，500表示服务器在执行请求时发生错误</span></span><br><span class="line">    send_str(client, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"\r\n"</span>);</span><br><span class="line">    send_str(client, <span class="string">"&lt;p&gt;error prohibited CGI execution.\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直很好奇web的工作原理，加之这阵子也在学习Python爬虫，就有想法了解这部分的知识，所以买了一本图解HTTP。&lt;br&gt;这本书简洁清晰也很形象地介绍了HTTP协议的工作流程，对零基础了解HTTP协议有着不错的引导作用。&lt;br&gt;书也很薄，可以很快看完。不过纯粹通过看书学习一个协议难免会浮于表面，因此，我找了TinyHttpd的source code来了解http协议的实现和实际工作场景。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://donald-zhuang.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="http" scheme="https://donald-zhuang.github.io/tags/http/"/>
    
      <category term="tinyhttpd" scheme="https://donald-zhuang.github.io/tags/tinyhttpd/"/>
    
  </entry>
  
</feed>
